<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Basic Page Needs -->
    <title>Vanilla JS Drop-in Annotation System</title>
    <meta name="description" content="A zero-dependency, self-contained commenting and highlighting tool for any static HTML page.">
    <meta name="author" content="">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://example.com/">
    <meta property="og:title" content="Vanilla JS Drop-in Annotation System">
    <meta property="og:description" content="A zero-dependency, self-contained commenting and highlighting tool for any static HTML page.">
    <meta property="og:image" content="https://example.com/image.jpg">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://example.com/">
    <meta property="twitter:title" content="Vanilla JS Drop-in Annotation System">
    <meta property="twitter:description" content="A zero-dependency, self-contained commenting and highlighting tool for any static HTML page.">
    <meta property="twitter:image" content="https://example.com/image.jpg">
<style>
body { max-width: 65ch; font-size: 1.1em; margin: auto auto; font-family: sans-serif; background-color: #222; color: #eee; padding: 5px 20px; }
p, li { line-height: 1.4em; text-align: justify; word-wrap: break-word; hyphens: auto; }
li { margin-top: 10px; }
li li { margin-left: 20px; }
ul, ol { margin-left: 0; padding-left: 0; }
h1, h2, h3, h4, h5, h6 { text-align: center; }
</style>
      </head>
<body>
    <main id="content">
        <h1 id="vanilla-js-drop-in-annotation-system">Vanilla JS Drop-in Annotation System</h1>
        <p>A zero-dependency, self-contained commenting and highlighting tool for any static HTML page. This system allows users to annotate text, auto-saves their comments locally, and lets them share their comments with others via compressed links or JSON files, all without requiring a server or external libraries.</p>
        <h2 id="core-features">Core Features</h2>
        <ul>
            <li><strong>Self-Contained:</strong> The entire system—HTML, CSS, and JavaScript—can be pasted into any existing static HTML file, right at the end. No external files, build systems, or anything else are needed.</li>
            <li><strong>Zero Dependencies:</strong> Written in modern, vanilla JavaScript. No need for jQuery, React, Vue, or any other framework.</li>
            <li><strong>Purely Client-Side:</strong> All data is processed and stored exclusively in the user's browser. No server is required, and no data is ever sent over the network, ensuring complete privacy.</li>
            <li><strong>Persistent Local Storage:</strong> Comments are automatically saved to the browser's <code>localStorage</code>, so they persist even after closing the tab or browser.</li>
            <li><strong>Robust Highlighting:</strong> The system can reliably highlight anything from text within an element to selections that span multiple elements, anywhere on the page.</li>
            <li><strong>Best-case Collaboration Features:</strong> When you import other people's comments, your own are preserved, and next time you export, the combined comments are exported together, allowing conversations (made easier with self-contained link sharing). Even better, the authorship of each comment is maintained, with different author names and associated colors (based on a hash function). On top of that, "resolve" functionality allows you to mark which comments you've delt with, without losing comment history.</li>
            <li><strong>Resilient Data Model:</strong> Annotations are saved using a precise DOM path, with a smart text-search fallback to ensure that comments can be imported and restored even if the underlying page structure has minor changes.</li>
            <li><strong>Two Ways to Share:</strong><ol>
            <li><strong>Shareable Links:</strong> Generates a compressed, URL-safe Base64 link that contains all comment data. Perfect for directly sharing an annotated version of the page.</li>
            <li><strong>Import/Export:</strong> Users can download their comments as a <code>.json</code> file for backup or sharing extremely large comment sets (over ~2,300 comments, which is the length at which Chrome stops displaying URL characters), and import files from others.</li>
            </ol>
            </li>
            <li><strong>Intuitive UI &amp; UX:</strong><ul>
            <li>An immersive UI that tries to remain as unobtrusive as possible.</li>
            <li>A central management widget that appears on hover.</li>
            <li>A complete comment list at the end of the document for easy navigation.</li>
            <li>Helpful keyboard shortcuts (<code>Shift+Enter</code> to comment/submit, <code>Esc</code> to cancel).</li>
            <li>Click-to-show tooltips with easy comment deletion.</li>
            <li>Fully responsive for both desktop and mobile use.</li>
            <li>Click on the management widget to jump to the next comment, to save you scrolling in long documents.</li>
            </ul>
            </li>
        </ul>
        <h2 id="installation">Installation</h2>
        <p>Adding this system to any existing HTML page is a simple three-step process:</p>
        <ol>
            <li><p><strong>Add the HTML:</strong> Copy the HTML for the UI elements and paste it right before the closing <code>&lt;/body&gt;</code> tag in your file. This includes the main UI container, the corner widget, and the comment summary section.</p>
            </li>
            <li><p><strong>Add the CSS:</strong> Copy the entire <code>&lt;style&gt;...&lt;/style&gt;</code> block and paste it inside your <code>&lt;head&gt;</code> tag or right before the HTML you just added.</p>
            </li>
            <li><p><strong>Add the JavaScript:</strong> Copy the entire final <code>&lt;script&gt;...&lt;/script&gt;</code> block and paste it at the very end of your file, right before the closing <code>&lt;/body&gt;</code> tag and after the UI HTML.</p>
            <p><strong>Important:</strong> The script initializes itself by targeting the element with the ID <code>content</code>. If your main text container has a different ID, simply change the last line of the script:</p>
            <pre><code class="lang-javascript"><span class="hljs-regexp">//</span> Change <span class="hljs-string">'content'</span> to the ID <span class="hljs-keyword">of</span> your main text container
<span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'DOMContentLoaded'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        initializeCommentingSystem(<span class="hljs-string">'your-content-id-here'</span>);
});
        </code></pre>
            </li>
        </ol>
        <p>That's it! Your page now has a complete annotation system.</p>
        <h2 id="how-it-works">How It Works</h2>
        <p>The system is designed for maximum resilience and portability.</p>
        <ul>
            <li><strong>Annotation Positioning:</strong> When a comment is created, the system saves the precise location of the highlight using a serialized DOM <code>Range</code>. This includes the node path from the root element and character offsets. When loading comments, it attempts to reconstruct this path.</li>
            <li><strong>Resilient Fallback:</strong> If a path cannot be found (due to minor HTML changes or browser parsing differences), the system intelligently falls back to searching for the highlight's saved text content within the expected area, dramatically increasing the durability of saved comments.</li>
            <li><strong>Shareable Link Compression:</strong> To avoid creating impractically long URLs, the "Copy Link" feature first compresses the entire JSON data of the comments using the browser's built-in Gzip compression stream before encoding it into a URL-safe Base64 string. This reduces the final data size by over 90%, making links practical for sharing.</li>
        </ul>
        <h2 id="vibe-coding-disclaimer">Vibe Coding Disclaimer</h2>
        <p>Usually even when I do AI-assisted coding I read every diff, design every architecture and algorithm decision before I even talk to the LLM, and I'm very careful and picky. I also use agentic coding systems to have tigher control over what they do, since every change is diffed. Not so here. I did this straight in a Gemini 2.5 Pro chat and literally didn't look at the code at all. So take that as you will. I'm not claiming this is my work, just that it's a really useful little tool for me, to replace the only thing I use Google Docs for, and someone might find it useful too.</p>
    </main>
<style>
 :root {
     --comment-highlight-bg: rgba(51, 255, 153, 0.4);
     --comment-ui-bg: #1a2a1a;
     --comment-ui-text: #e8f8e8;
     --comment-ui-accent: #33ff99;
     --comment-ui-border: #6a826a;
 }

 .comment-highlight {
     background-color: var(--comment-highlight-bg);
     border-bottom: 2px dashed var(--comment-ui-accent);
     cursor: pointer;
     color: inherit;
 }

 /* Main Comment Creation Drawer */
 #comment-ui-container {
     position: absolute;
     bottom: 0;
     left: 0;
     width: 100%;
     background-color: var(--comment-ui-bg);
     color: var(--comment-ui-text);
     box-shadow: 0 -2px 10px rgba(0,0,0,0.5);
     z-index: 10000;
     transform: translateY(100%);
     transition: transform 0.3s ease-in-out;
     padding: 1rem;
     box-sizing: border-box;
     display: flex;
     flex-direction: column;
     gap: 0.75rem;
     border-top: 1px solid var(--comment-ui-border);
 }

 #comment-ui-container.visible {
     transform: translateY(0);
 }

 #comment-ui-container button {
     background-color: var(--comment-ui-accent);
     color: var(--bg-color);
     font-weight: bold;
     border: none;
     padding: 0.6rem 1rem;
     border-radius: 5px;
     cursor: pointer;
     font-size: 0.9rem;
     font-family: sans-serif;
     text-align: center;
 }

 #comment-ui-container button.secondary {
     background-color: var(--comment-ui-border);
     color: var(--comment-ui-text);
     font-weight: normal;
 }

 #comment-ui-container button:hover {
     opacity: 0.85;
 }

 #comment-input-area {
     width: 100%;
     background-color: #0c140c;
     color: var(--comment-ui-text);
     border: 1px solid var(--comment-ui-border);
     border-radius: 5px;
     padding: 0.5rem;
     font-size: 1rem;
     font-family: sans-serif;
     min-height: 80px;
     box-sizing: border-box;
     resize: vertical;
 }

 #comment-form {
     display: none;
     flex-direction: column;
     gap: 0.75rem;
 }

 #comment-form .form-buttons {
     display: flex;
     gap: 0.5rem;
     justify-content: flex-end;
 }

 /* Tooltip */
 #comment-tooltip {
     position: absolute;
     display: none;
     background-color: var(--comment-ui-bg);
     color: var(--comment-ui-text);
     border: 1px solid var(--comment-ui-border);
     border-radius: 5px;
     padding: 0.8rem;
     max-width: 300px;
     font-size: 0.9rem;
     z-index: 10001;
     box-shadow: 0 4px 8px rgba(0,0,0,0.3);
     overflow-wrap: break-word;
     font-family: sans-serif;
     line-height: 1.5;
 }

 .delete-comment-btn {
     background: var(--comment-ui-border);
     color: var(--comment-ui-text);
     border: none;
     padding: 4px 8px;
     margin-top: 8px;
     border-radius: 3px;
     cursor: pointer;
     display: block;
     width: 100%;
     font-size: 0.8rem;
 }

 .delete-comment-btn:hover {
     background: #c13434;
 }

 /* Management Widget in Corner */
 #comment-widget-container {
     position: absolute;
     bottom: 15px;
     right: 15px;
     z-index: 9999;
     display: flex;
     flex-direction: column-reverse;
     align-items: flex-end;
 }

 #comment-counter {
     background-color: rgba(26, 42, 26, 0.8);
     backdrop-filter: blur(5px);
     color: var(--comment-ui-text);
     padding: 5px 12px;
     margin-top: 8px;
     border-radius: 15px;
     font-size: 0.85rem;
     font-family: sans-serif;
     display: none;
     box-shadow: 0 1px 4px rgba(0,0,0,0.4);
     border: 1px solid var(--comment-ui-border);
     cursor: default;
     transition: transform 0.2s ease-out;
 }

 #comment-management-wrapper {
     display: flex;
     flex-direction: column;
     align-items: flex-end;
     gap: 8px;
     opacity: 0;
     visibility: hidden;
     transform: translateY(10px);
     transition: all 0.2s ease-out;
 }

 #comment-management-flyout {
     display: flex;
     gap: 0.5rem;
     padding: 8px;
     background-color: rgba(26, 42, 26, 0.9);
     backdrop-filter: blur(5px);
     border: 1px solid var(--comment-ui-border);
     border-radius: 8px;
 }

 #comment-management-help-text {
     color: var(--comment-ui-border);
     font-size: 0.75rem;
     font-family: sans-serif;
     text-align: right;
     padding: 0 4px;
     max-width: 250px;
 }

 #comment-widget-container:hover #comment-management-wrapper {
     opacity: 1;
     visibility: visible;
     transform: translateY(0);
 }

 #comment-widget-container:hover #comment-counter {
     transform: scale(1.05);
 }

 #comment-management-flyout button,
 #comment-management-flyout .file-input-label {
     background-color: var(--comment-ui-accent);
     color: var(--bg-color);
     font-weight: bold;
     border: none;
     padding: 0.5rem 0.8rem;
     border-radius: 5px;
     cursor: pointer;
     font-size: 0.8rem;
     font-family: sans-serif;
     white-space: nowrap;
     display: flex;
     align-items: center;
     justify-content: center;
 }

 #comment-management-flyout button.secondary {
     background-color: var(--comment-ui-border);
     color: var(--comment-ui-text);
     font-weight: normal;
 }

 #comment-management-flyout button:hover,
 #comment-management-flyout .file-input-label:hover {
     opacity: 0.85;
 }

 #copy-link-btn {
     background-color: #4A5D4A;
 }

 #import-comments-input {
     display: none;
 }

 /* Help Text and Keybinding Styles */
 .comment-help-text {
     font-size: 0.8rem;
     color: var(--comment-ui-border);
     text-align: center;
     width: 100%;
 }

 .comment-help-text kbd {
     background-color: #0c140c;
     border: 1px solid var(--comment-ui-border);
     padding: 2px 6px;
     border-radius: 4px;
     font-family: monospace;
     font-size: 0.75rem;
 }

 /* Comment Summary Section Styles */
 #comment-summary-section {
     max-width: 60em;
     margin: 5em auto;
     padding: 2em;
     border-top: 2px solid var(--comment-ui-border);
     color: var(--comment-ui-text);
 }

 #comment-summary-section h2 {
     font-family: var(--font-heading);
     color: var(--comment-ui-accent);
     text-transform: uppercase;
     margin-top: 0;
     border-bottom: none;
     margin-bottom: 1em;
 }

 #comment-summary-list {
     list-style: none;
     padding: 0;
     margin: 0;
 }

 #comment-summary-list li {
     padding: 1.5em;
     border-bottom: 1px solid var(--comment-ui-border);
     cursor: pointer;
     transition: background-color 0.2s ease;
     position: relative;
 }

 #comment-summary-list li:hover {
     background-color: var(--comment-ui-bg);
 }

 #comment-summary-list li blockquote {
     margin: 0 0 0.5em 0;
     padding-left: 1em;
     border-left: 3px solid var(--comment-ui-accent);
     color: var(--comment-ui-text);
     font-style: italic;
     opacity: 0.8;
 }

 #comment-summary-list li p {
     margin: 0;
     color: var(--comment-ui-text);
     font-family: sans-serif;
 }

 .summary-delete-btn {
     position: absolute;
     top: 5px;
     right: 5px;
     font-size: 1.5rem;
     color: var(--comment-ui-border);
     transition: color 0.2s ease;
     line-height: 1;
     padding: 10px;
 }

 .summary-delete-btn:hover {
     color: #c13434;
 }

 /* Mobile Responsiveness */
 @media (min-width: 600px) {
     #comment-ui-container {
         width: 500px;
         max-width: 90%;
         left: 50%;
         transform: translateX(-50%) translateY(120%);
         border-top-left-radius: 8px;
         border-top-right-radius: 8px;
     }

     #comment-ui-container.visible {
         transform: translateX(-50%) translateY(0);
     }
 }

 /* Style for Resolve button in tooltip and summary */
 .resolve-comment-btn {
     background-color: var(--comment-ui-accent);
     color: var(--bg-color);
     font-weight: bold;
     border: none;
     padding: 4px 8px;
     margin-top: 8px;
     margin-right: 5px;
     border-radius: 3px;
     cursor: pointer;
     font-size: 0.8rem;
 }

 .resolve-comment-btn:hover {
     opacity: 0.85;
 }

 .summary-unresolve-btn {
     background-color: var(--comment-ui-accent);
     color: var(--bg-color);
     font-weight: bold;
     border: none;
     padding: 6px 12px;
     border-radius: 4px;
     cursor: pointer;
     font-size: 0.85rem;
     margin-top: 10px;
     display: inline-block;
 }

 .summary-unresolve-btn:hover {
     opacity: 0.85;
 }

 /* Make the counter look clickable */
 #comment-counter.has-comments {
     cursor: pointer;
 }

 /* Author Attribution Styles */
 .comment-author {
     display: block;
     font-size: 0.8rem;
     font-weight: bold;
     opacity: 0.7;
     margin-bottom: 0.5em;
 }

 #comment-tooltip .comment-author {
     color: var(--comment-ui-accent);
 }

 .summary-author {
     font-weight: bold;
     margin-bottom: 0.5em;
     font-family: sans-serif;
     font-size: 0.9em;
 }

 /* Sandboxed Root Container */
 #commenting-system-root {
     position: fixed;
     top: 0;
     left: 0;
     width: 100%;
     height: 100%;
     z-index: 2147483647;
     pointer-events: none;
     font-family: sans-serif;
     font-size: 16px;
     line-height: 1.5;
 }

 #commenting-system-root > * {
     pointer-events: auto;
 }
</style>

<div id="commenting-system-root">
    <div id="comment-tooltip"></div>

    <div id="comment-widget-container">
        <div id="comment-counter"></div>
        <div id="comment-management-wrapper">
            <div id="comment-management-flyout">
                <button id="copy-link-btn">Copy Link</button>
                <label for="import-comments-input" class="file-input-label">Import</label>
                <input type="file" id="import-comments-input" accept=".json"/>
                <button id="export-comments-btn">Export</button>
                <button id="clear-comments-btn" class="secondary">Clear All</button>
            </div>
            <small id="comment-management-help-text">
                Comments are stored locally in your browser. Use Export/Import or Copy Link to share.
            </small>
        </div>
    </div>

    <div id="comment-ui-container">
        <button id="add-comment-btn" style="display: none;">Add Comment</button>
        <div id="add-comment-help-text" class="comment-help-text" style="display: none;">
            Press <kbd>Shift</kbd> + <kbd>Enter</kbd> to add comment
        </div>
        <form id="comment-form">
            <textarea id="comment-input-area" placeholder="Type your comment here..."></textarea>
            <div class="comment-help-text">
                <kbd>Shift</kbd> + <kbd>Enter</kbd> to save, <kbd>Esc</kbd> to cancel
            </div>
            <div class="form-buttons">
                <button type="button" id="cancel-comment-btn" class="secondary">Cancel</button>
                <button type="submit" id="save-comment-btn">Save</button>
            </div>
        </form>
    </div>
</div>

<section id="comment-summary-section" style="display: none;">
    <h2>Comment Summary</h2>
    <ol id="comment-summary-list"></ol>
</section>


<script>
(function() {
    'use strict';

    /**
     * ===================================================================
     *  1. MODULE DEFINITIONS
     * ===================================================================
     */
    const CommentingSystem = {

        // --- Utils Module ---
        Utils: {
            escapeHTML(str) {
                const div = document.createElement('div');
                div.textContent = str;
                return div.innerHTML;
            },
            generateUUID() {
                return 'comment-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            },
            toUrlSafeBase64(buffer) {
                return btoa(String.fromCharCode.apply(null, new Uint8Array(buffer)))
                    .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
            },
            fromUrlSafeBase64(str) {
                str = str.replace(/-/g, '+').replace(/_/g, '/');
                while (str.length % 4) { str += '='; }
                const binaryString = atob(str);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            },
            async compressData(data) {
                if (!window.CompressionStream) {
                    console.warn("CompressionStream API not supported. Sharing links may be less reliable.");
                    return new TextEncoder().encode(JSON.stringify(data));
                }
                const stream = new Blob([JSON.stringify(data)], { type: 'application/json' })
                    .stream().pipeThrough(new CompressionStream('gzip'));
                return await new Response(stream).arrayBuffer();
            },
            async decompressData(compressedBuffer) {
                if (!window.DecompressionStream) {
                    console.warn("DecompressionStream API not supported. Cannot load comments from compressed link.");
                    return null;
                }
                try {
                    const stream = new Blob([compressedBuffer], { type: 'application/gzip' })
                        .stream().pipeThrough(new DecompressionStream('gzip'));
                    return await new Response(stream).json();
                } catch (e) {
                    console.error("Decompression failed:", e);
                    return null;
                }
            },
            getAuthorColor(author) {
                if (!author) return { border: '#33ff99', background: 'rgba(51, 255, 153, 0.4)' };
                let hash = 0;
                for (let i = 0; i < author.length; i++) {
                    hash = author.charCodeAt(i) + ((hash << 5) - hash);
                }
                const h = hash % 360;
                return {
                    border: `hsl(${h}, 70%, 40%)`,
                    background: `hsla(${h}, 70%, 85%, 0.4)`
                };
            }
        },

        // --- State Module ---
        State: {
            comments: [],
            currentUser: 'Anonymous',
            currentSelection: null,
            listeners: {},
            init() {
                this.comments = [];
                this.currentUser = 'Anonymous';
                this.currentSelection = null;
                this.listeners = {};
            },
            on(eventName, callback) {
                if (!this.listeners[eventName]) {
                    this.listeners[eventName] = [];
                }
                this.listeners[eventName].push(callback);
            },
            emit(eventName, data) {
                if (this.listeners[eventName]) {
                    this.listeners[eventName].forEach(callback => callback(data));
                }
            },
            setComments(newComments) {
                if (Array.isArray(newComments)) {
                    this.comments = newComments;
                    this.emit('load', this.comments);
                    this.emit('change');
                }
            },
            addComment(commentData) {
                const newComment = {
                    id: CommentingSystem.Utils.generateUUID(),
                    text: commentData.text,
                    range: commentData.range,
                    author: this.currentUser,
                    isResolved: false
                };
                this.comments.push(newComment);
                this.emit('comment:added', newComment);
                this.emit('change');
            },
            deleteComment(commentId) {
                const comment = this.comments.find(c => c.id === commentId);
                if (comment) {
                    this.comments = this.comments.filter(c => c.id !== commentId);
                    this.emit('comment:deleted', comment);
                    this.emit('change');
                }
            },
            resolveComment(commentId, isResolved = true) {
                const comment = this.comments.find(c => c.id === commentId);
                if (comment) {
                    comment.isResolved = isResolved;
                    this.emit('comment:resolved', comment);
                    this.emit('change');
                }
            },
            setCurrentSelection(selectionData) { this.currentSelection = selectionData; },
            setCurrentUser(username) { this.currentUser = username; }
        },

        // --- DOM Module ---
        DOM: {
            elements: {},
            init(contentRootNode) {
                this.elements = {
                    contentRoot: contentRootNode,
                    commentingRoot: document.getElementById('commenting-system-root'),
                    tooltip: document.getElementById('comment-tooltip'),
                    widgetContainer: document.getElementById('comment-widget-container'),
                    counter: document.getElementById('comment-counter'),
                    uiContainer: document.getElementById('comment-ui-container'),
                    addCommentBtn: document.getElementById('add-comment-btn'),
                    addCommentHelpText: document.getElementById('add-comment-help-text'),
                    commentForm: document.getElementById('comment-form'),
                    commentInput: document.getElementById('comment-input-area'),
                    summarySection: document.getElementById('comment-summary-section'),
                    summaryList: document.getElementById('comment-summary-list'),
                };
            },
            renderCommentSummary(comments) {
                this.elements.summaryList.innerHTML = '';
                if (comments.length === 0) {
                    this.elements.summarySection.style.display = 'none';
                    return;
                }
                this.elements.summarySection.style.display = 'block';
                comments.forEach(comment => {
                    const li = document.createElement('li');
                    li.dataset.commentId = comment.id;
                    const authorColors = CommentingSystem.Utils.getAuthorColor(comment.author);
                    const quoteText = comment.range.text.length > 100 ? comment.range.text.substring(0, 97) + '...' : comment.range.text;
                    li.innerHTML = `
                        <span class="summary-delete-btn" data-comment-id="${comment.id}">&times;</span>
                        <div class="summary-author" style="color: ${authorColors.border};">By: ${CommentingSystem.Utils.escapeHTML(comment.author)}</div>
                        <blockquote style="border-left-color: ${authorColors.border};">${CommentingSystem.Utils.escapeHTML(quoteText)}</blockquote>
                        <p>${CommentingSystem.Utils.escapeHTML(comment.text)}</p>
                        ${comment.isResolved ? `<button class="summary-unresolve-btn" data-comment-id="${comment.id}">Unresolve</button>` : ''}
                    `;
                    if (comment.isResolved) li.classList.add('resolved');
                    this.elements.summaryList.appendChild(li);
                });
            },
            updateCounter(comments) {
                const totalCount = comments.length;
                this.elements.counter.style.display = 'block';
                if (totalCount === 0) {
                    this.elements.counter.textContent = 'No Comments';
                    this.elements.counter.classList.remove('has-comments');
                    return;
                }
                const placedCount = document.querySelectorAll('.comment-highlight').length;
                this.elements.counter.textContent = `${placedCount} Comment${placedCount !== 1 ? 's' : ''}`;
                if (placedCount > 0) this.elements.counter.classList.add('has-comments');
                else this.elements.counter.classList.remove('has-comments');
            },
            showTooltip(comment, highlightEl) {
                if (!comment) return;
                const authorColors = CommentingSystem.Utils.getAuthorColor(comment.author);
                this.elements.tooltip.innerHTML = `
                    <small class="comment-author" style="color: ${authorColors.border};">By: ${CommentingSystem.Utils.escapeHTML(comment.author)}</small>
                    <span>${CommentingSystem.Utils.escapeHTML(comment.text)}</span> <br/>
                    <button class="resolve-comment-btn" data-comment-id="${comment.id}">Resolve</button>
                    <button class="delete-comment-btn" data-comment-id="${comment.id}">Delete</button>`;
                this.elements.tooltip.style.display = 'block';
                this.elements.tooltip.dataset.activeCommentId = comment.id;
                const highlightRect = highlightEl.getBoundingClientRect();
                const tooltipRect = this.elements.tooltip.getBoundingClientRect();
                let newLeft = highlightRect.left;
                if (newLeft + tooltipRect.width > window.innerWidth) newLeft = window.innerWidth - tooltipRect.width - 10;
                newLeft = Math.max(10, newLeft);
                let newTop = highlightRect.bottom + 5;
                if (newTop + tooltipRect.height > window.innerHeight) newTop = highlightRect.top - tooltipRect.height - 5;
                newTop = Math.max(10, newTop);
                this.elements.tooltip.style.left = `${newLeft}px`;
                this.elements.tooltip.style.top = `${newTop}px`;
            },
            hideTooltip() { this.elements.tooltip.style.display = 'none'; this.elements.tooltip.dataset.activeCommentId = ''; },
            showCommentDrawer() { this.elements.uiContainer.classList.add('visible'); this.elements.addCommentBtn.style.display = 'block'; this.elements.addCommentHelpText.style.display = 'block'; this.elements.commentForm.style.display = 'none'; },
            showCommentForm() { this.elements.addCommentBtn.style.display = 'none'; this.elements.addCommentHelpText.style.display = 'none'; this.elements.commentForm.style.display = 'flex'; this.elements.commentInput.focus(); },
            resetUI() { this.elements.uiContainer.classList.remove('visible'); this.elements.addCommentBtn.style.display = 'none'; this.elements.addCommentHelpText.style.display = 'none'; this.elements.commentForm.style.display = 'none'; this.elements.commentInput.value = ''; if (window.getSelection) window.getSelection().removeAllRanges(); },
            removeHighlight(commentId) {
                document.querySelectorAll(`.comment-highlight[data-comment-id="${commentId}"]`).forEach(el => {
                    const parent = el.parentNode;
                    if (parent) {
                        while (el.firstChild) parent.insertBefore(el.firstChild, el);
                        parent.removeChild(el);
                        parent.normalize();
                    }
                });
            }
        },

        // --- Highlighting Module ---
        Highlighting: {
            contentRoot: null,
            init(contentRootNode) { this.contentRoot = contentRootNode; },
            getNodePath(node) {
                const path = [];
                while (node && node !== this.contentRoot) {
                    let sibling = node, index = 0;
                    while ((sibling = sibling.previousSibling) != null) index++;
                    path.unshift(index);
                    node = node.parentNode;
                }
                return path;
            },
            getNodeFromPath(path) {
                if (!Array.isArray(path)) return null;
                let node = this.contentRoot;
                for (const index of path) {
                    if (!Number.isInteger(index) || index < 0 || !node || !node.childNodes[index]) return null;
                    node = node.childNodes[index];
                }
                return node;
            },
            serializeRange(range) {
                if (!range) return null;
                return { startPath: this.getNodePath(range.startContainer), startOffset: range.startOffset, endPath: this.getNodePath(range.endContainer), endOffset: range.endOffset, text: range.toString() };
            },
            deserializeRange(savedRange) {
                const startContainer = this.getNodeFromPath(savedRange.startPath);
                const endContainer = this.getNodeFromPath(savedRange.endPath);
                if (startContainer && endContainer) {
                    try {
                        const range = document.createRange();
                        range.setStart(startContainer, Math.min(savedRange.startOffset, startContainer.textContent.length));
                        range.setEnd(endContainer, Math.min(savedRange.endOffset, endContainer.textContent.length));
                        return range;
                    } catch (e) { console.error("Error creating range from path.", e, savedRange); }
                }
                const walker = document.createTreeWalker(this.contentRoot, NodeFilter.SHOW_TEXT);
                let node;
                const normalizedText = savedRange.text.replace(/\s+/g, ' ').trim();
                if (!normalizedText) return null;
                while (node = walker.nextNode()) {
                    const index = node.nodeValue.replace(/\s+/g, ' ').indexOf(normalizedText);
                    if (index !== -1) {
                        const range = document.createRange();
                        range.setStart(node, index);
                        range.setEnd(node, index + normalizedText.length);
                        return range;
                    }
                }
                return null;
            },
            applyHighlight(range, comment) {
                if (!range || range.collapsed) return null;
                const authorColors = CommentingSystem.Utils.getAuthorColor(comment.author);
                const marker = document.createElement('mark');
                marker.className = 'comment-highlight';
                marker.dataset.commentId = comment.id;
                marker.style.backgroundColor = authorColors.background;
                marker.style.borderBottomColor = authorColors.border;
                try {
                    range.surroundContents(marker);
                } catch (e) {
                    console.warn("surroundContents failed. Using robust fallback.", e);
                    const walker = document.createTreeWalker(range.commonAncestorContainer, NodeFilter.SHOW_TEXT);
                    const textNodes = [];
                    while (walker.nextNode()) {
                        if (range.intersectsNode(walker.currentNode)) textNodes.push(walker.currentNode);
                    }
                    for (const node of textNodes) {
                        const highlightRange = document.createRange();
                        highlightRange.setStart(node, node === range.startContainer ? range.startOffset : 0);
                        highlightRange.setEnd(node, node === range.endContainer ? range.endOffset : node.textContent.length);
                        if (!highlightRange.collapsed) {
                            const localMarker = marker.cloneNode(true);
                            highlightRange.surroundContents(localMarker);
                        }
                    }
                }
            },
            applyAllHighlights(comments) {
                const itemsToHighlight = comments
                    .filter(c => !c.isResolved)
                    .map(comment => ({ comment, range: this.deserializeRange(comment.range) }))
                    .filter(item => item.range)
                    .sort((a, b) => b.range.compareBoundaryPoints(Range.START_TO_START, a.range));
                itemsToHighlight.forEach(item => this.applyHighlight(item.range, item.comment));
            }
        },
        
        // --- Persistence Module ---
        Persistence: {
            State: null, Utils: null,
            init(stateModule, utilsModule) {
                this.State = stateModule;
                this.Utils = utilsModule;
            },
            saveToLocal() { try { localStorage.setItem('userComments', JSON.stringify(this.State.comments)); } catch (e) { console.error("Could not save comments to localStorage.", e); } },
            async loadInitialComments() {
                let localComments = this.loadFromLocal();
                const hash = window.location.hash.slice(1);
                if (hash) {
                    try {
                        const buffer = this.Utils.fromUrlSafeBase64(hash);
                        const urlComments = await this.Utils.decompressData(buffer);
                        if (urlComments && Array.isArray(urlComments)) {
                            const existingCommentTexts = new Set(localComments.map(c => c.range.text));
                            const newComments = urlComments.filter(c => c.range && c.range.text && !existingCommentTexts.has(c.range.text)).map(comment => ({ ...comment, id: this.Utils.generateUUID() }));
                            localComments.push(...newComments);
                            history.replaceState(null, '', window.location.pathname + window.location.search);
                        }
                    } catch (e) { console.error("Failed to load comments from URL", e); }
                }
                this.State.setComments(localComments);
            },
            loadFromLocal() {
                const savedCommentsJSON = localStorage.getItem('userComments');
                if (savedCommentsJSON) {
                    try { return JSON.parse(savedCommentsJSON) || []; } catch (e) { return []; }
                }
                return [];
            },
            getOrSetUser() {
                const savedUser = localStorage.getItem('commentingUser');
                if (savedUser) { this.State.setCurrentUser(savedUser); return; }
                const newUser = prompt("Please enter your name for commenting:", "Anonymous");
                const user = (newUser && newUser.trim()) ? newUser.trim() : 'Anonymous';
                this.State.setCurrentUser(user);
                localStorage.setItem('commentingUser', user);
            },
            async generateShareableLink(buttonEl) {
                if (this.State.comments.length === 0) return;
                const originalText = buttonEl.textContent;
                buttonEl.textContent = 'Compressing...';
                buttonEl.disabled = true;
                try {
                    const lightweightComments = this.State.comments.map(({ text, range, author }) => ({ text, range, author }));
                    const compressed = await this.Utils.compressData(lightweightComments);
                    const base64 = this.Utils.toUrlSafeBase64(compressed);
                    const url = new URL(window.location);
                    url.hash = base64;
                    await navigator.clipboard.writeText(url.href);
                    buttonEl.textContent = 'Copied!';
                } catch (err) { console.error("Failed to copy link:", err); buttonEl.textContent = 'Error!'; } finally {
                    setTimeout(() => { buttonEl.textContent = originalText; buttonEl.disabled = false; }, 2000);
                }
            },
            exportToFile() {
                if (this.State.comments.length === 0) { return; }
                const dataStr = JSON.stringify(this.State.comments, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'comments.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            },
            importFromFile(file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const importedComments = JSON.parse(event.target.result);
                        if (Array.isArray(importedComments)) {
                            const existingCommentTexts = new Set(this.State.comments.map(c => c.range.text));
                            const newComments = importedComments.filter(c => c.range && c.range.text && !existingCommentTexts.has(c.range.text)).map(c => ({ ...c, id: c.id || this.Utils.generateUUID() }));
                            this.State.setComments([...this.State.comments, ...newComments]);
                            alert(`${newComments.length} new comment(s) imported successfully.`);
                        }
                    } catch (err) { alert('Error: Could not parse file.'); }
                };
                reader.readAsText(file);
            }
        },

        // --- UI (Controller) Module ---
        UI: {
            modules: {},
            nextHighlightIndex: 0,
            init(modules) {
                this.modules = modules;
                this.bindEventListeners();
                this.initializeViewportPositioning();
                this.bindStateListeners();
            },
            syncRootWithViewport() {
                if (!window.visualViewport) return;
                const { offsetTop, offsetLeft, width, height } = window.visualViewport;
                const rootEl = this.modules.DOM.elements.commentingRoot;
                const trueTop = offsetTop + window.scrollY;
                const trueLeft = offsetLeft + window.scrollX;
                rootEl.style.transform = `translate(${trueLeft}px, ${trueTop}px)`;
                rootEl.style.width = `${width}px`;
                rootEl.style.height = `${height}px`;
            },
            initializeViewportPositioning() {
                const isMobileLike = navigator.maxTouchPoints > 0;
                if (isMobileLike && window.visualViewport) {
                    const rootEl = this.modules.DOM.elements.commentingRoot;
                    rootEl.style.position = 'absolute';
                    window.visualViewport.addEventListener('resize', this.syncRootWithViewport.bind(this));
                    window.visualViewport.addEventListener('scroll', this.syncRootWithViewport.bind(this));
                    this.syncRootWithViewport();
                }
            },
            bindStateListeners() {
                const { State, DOM, Highlighting, Persistence } = this.modules;
                State.on('load', (comments) => {
                    Highlighting.applyAllHighlights(comments);
                    this.addEventListenersToHighlights();
                });
                State.on('comment:added', (newComment) => {
                    const range = Highlighting.deserializeRange(newComment.range);
                    if (range) {
                        Highlighting.applyHighlight(range, newComment);
                        this.addEventListenersToHighlights();
                    }
                });
                State.on('comment:deleted', (deletedComment) => {
                    DOM.removeHighlight(deletedComment.id);
                });
                State.on('comment:resolved', (comment) => {
                    if (comment.isResolved) {
                        DOM.removeHighlight(comment.id);
                    } else {
                        const range = Highlighting.deserializeRange(comment.range);
                        if (range) {
                            Highlighting.applyHighlight(range, comment);
                            this.addEventListenersToHighlights();
                        }
                    }
                });
                State.on('change', () => {
                    DOM.renderCommentSummary(State.comments);
                    DOM.updateCounter(State.comments);
                    Persistence.saveToLocal();
                });
            },
            bindEventListeners() {
                const { contentRoot } = this.modules.DOM.elements;
                contentRoot.addEventListener('mouseup', this.handleSelectionEnd.bind(this));
                this.modules.DOM.elements.addCommentBtn.addEventListener('click', this.handleAddCommentClick.bind(this));
                this.modules.DOM.elements.commentForm.addEventListener('submit', this.handleSaveComment.bind(this));
                document.getElementById('cancel-comment-btn').addEventListener('click', () => this.modules.DOM.resetUI());
                this.modules.DOM.elements.commentInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && e.shiftKey) { e.preventDefault(); this.modules.DOM.elements.commentForm.requestSubmit(); }
                    if (e.key === 'Escape') { e.preventDefault(); this.modules.DOM.resetUI(); }
                });
                document.getElementById('export-comments-btn').addEventListener('click', () => this.modules.Persistence.exportToFile());
                document.getElementById('import-comments-input').addEventListener('change', (e) => e.target.files[0] && this.modules.Persistence.importFromFile(e.target.files[0]));
                document.getElementById('copy-link-btn').addEventListener('click', (e) => this.modules.Persistence.generateShareableLink(e.target));
                document.getElementById('clear-comments-btn').addEventListener('click', this.handleClearAll.bind(this));
                document.addEventListener('click', this.handleDocumentClick.bind(this));
                this.modules.DOM.elements.summaryList.addEventListener('click', this.handleSummaryClick.bind(this));
                this.modules.DOM.elements.widgetContainer.addEventListener('click', this.handleCycleHighlights.bind(this));
            },
            addEventListenersToHighlights() {
                document.querySelectorAll('.comment-highlight').forEach(marker => {
                    if (marker.dataset.listenerAttached) return;
                    marker.addEventListener('click', this.handleHighlightClick.bind(this));
                    marker.dataset.listenerAttached = 'true';
                });
            },
            handleSelectionEnd(e) {
                if (e.target.closest('#commenting-system-root')) return;
                setTimeout(() => {
                    const selection = window.getSelection();
                    if (selection && !selection.isCollapsed && this.modules.DOM.elements.contentRoot.contains(selection.anchorNode)) {
                        this.modules.DOM.showCommentDrawer();
                    } else if (document.activeElement !== this.modules.DOM.elements.commentInput) {
                        this.modules.DOM.resetUI();
                    }
                }, 10);
            },
            handleAddCommentClick() {
                const selection = window.getSelection();
                if (selection && !selection.isCollapsed) {
                    const serializedRange = this.modules.Highlighting.serializeRange(selection.getRangeAt(0));
                    this.modules.State.setCurrentSelection(serializedRange);
                    this.modules.Persistence.getOrSetUser();
                    this.modules.DOM.showCommentForm();
                }
            },
            handleSaveComment(e) {
                e.preventDefault();
                const { State, DOM } = this.modules;
                const text = DOM.elements.commentInput.value.trim();
                const rangeData = State.currentSelection;
                if (text && rangeData) {
                    State.addComment({ text, range: rangeData });
                    DOM.resetUI();
                }
            },
            handleHighlightClick(e) {
                e.stopPropagation();
                const { DOM, State } = this.modules;
                const marker = e.target.closest('.comment-highlight');
                if (!marker) return;
                const commentId = marker.dataset.commentId;
                if (DOM.elements.tooltip.dataset.activeCommentId === commentId) {
                    DOM.hideTooltip();
                } else {
                    const comment = State.comments.find(c => c.id === commentId);
                    if (comment) DOM.showTooltip(comment, marker);
                }
            },
            handleDocumentClick(e) {
                const { DOM, State } = this.modules;
                if (!e.target.closest('.comment-highlight') && !e.target.closest('#comment-tooltip')) DOM.hideTooltip();
                const deleteBtn = e.target.closest('.delete-comment-btn');
                if (deleteBtn && confirm('Are you sure you want to delete this comment?')) {
                    State.deleteComment(deleteBtn.dataset.commentId);
                    DOM.hideTooltip();
                }
                const resolveBtn = e.target.closest('.resolve-comment-btn');
                if (resolveBtn) {
                    State.resolveComment(resolveBtn.dataset.commentId, true);
                    DOM.hideTooltip();
                }
            },
            handleSummaryClick(e) {
                const { DOM, State } = this.modules;
                const li = e.target.closest('li');
                if (!li) return;
                const commentId = li.dataset.commentId;
                if (e.target.closest('.summary-delete-btn') && confirm('Are you sure you want to delete this comment?')) {
                    State.deleteComment(commentId);
                } else if (e.target.closest('.summary-unresolve-btn')) {
                    State.resolveComment(commentId, false);
                } else {
                    const highlightEl = document.querySelector(`.comment-highlight[data-comment-id="${commentId}"]`);
                    if (highlightEl) {
                        highlightEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        setTimeout(() => {
                           const comment = State.comments.find(c => c.id === commentId);
                           DOM.showTooltip(comment, highlightEl);
                        }, 300);
                    }
                }
            },
            // FIX: The handler now explicitly removes DOM elements before clearing the state.
            handleClearAll() {
                const { State, DOM } = this.modules;
                if (confirm('Are you sure you want to permanently delete all comments?')) {
                    // 1. Explicitly remove all highlight DOM elements.
                    [...State.comments].forEach(comment => {
                        DOM.removeHighlight(comment.id);
                    });
                    // 2. Now, update the application state.
                    State.setComments([]);
                    history.replaceState(null, '', window.location.pathname);
                }
            },
            handleCycleHighlights(e) {
                if (e.target.closest('#comment-management-flyout')) return;
                const highlights = Array.from(document.querySelectorAll('.comment-highlight')).sort((a, b) => a.offsetTop - b.offsetTop);
                if (highlights.length === 0) return;
                if (this.nextHighlightIndex >= highlights.length) this.nextHighlightIndex = 0;
                const nextHighlight = highlights[this.nextHighlightIndex];
                if (nextHighlight) {
                    nextHighlight.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    nextHighlight.click();
                }
                this.nextHighlightIndex = (this.nextHighlightIndex + 1) % highlights.length;
            }
        }
    };

    /**
     * ===================================================================
     *  2. PUBLIC INITIALIZER
     * ===================================================================
     */
    window.initializeCommentingSystem = async function(rootElementId) {
        if (window.commentingSystemInitialized) return;

        const { State, DOM, Highlighting, Persistence, UI } = CommentingSystem;
        const contentRootNode = document.getElementById(rootElementId) || document.body;

        State.init();
        
        DOM.init(contentRootNode);
        Highlighting.init(contentRootNode);
        Persistence.init(State, CommentingSystem.Utils);
        
        UI.init({ State, DOM, Highlighting, Persistence, Utils: CommentingSystem.Utils });

        Persistence.getOrSetUser();
        await Persistence.loadInitialComments();
        
        window.commentingSystemInitialized = true;
        console.log("Commenting system initialized successfully.");
    };

    /**
     * ===================================================================
     *  3. DOM READY HOOK
     * ===================================================================
     */
    document.addEventListener('DOMContentLoaded', () => {
        initializeCommentingSystem('content');
    });

})();
</script>
    
</body>
</html>
