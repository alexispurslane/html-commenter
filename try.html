<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Basic Page Needs -->
    <title>Vanilla JS Drop-in Annotation System</title>
    <meta name="description" content="A zero-dependency, self-contained commenting and highlighting tool for any static HTML page.">
    <meta name="author" content="">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://example.com/">
    <meta property="og:title" content="Vanilla JS Drop-in Annotation System">
    <meta property="og:description" content="A zero-dependency, self-contained commenting and highlighting tool for any static HTML page.">
    <meta property="og:image" content="https://example.com/image.jpg">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://example.com/">
    <meta property="twitter:title" content="Vanilla JS Drop-in Annotation System">
    <meta property="twitter:description" content="A zero-dependency, self-contained commenting and highlighting tool for any static HTML page.">
    <meta property="twitter:image" content="https://example.com/image.jpg">
<style>
body { max-width: 65ch; font-size: 1.1em; margin: auto auto; font-family: sans-serif; background-color: #222; color: #eee; padding: 5px 20px; }
p, li { line-height: 1.4em; text-align: justify; word-wrap: break-word; hyphens: auto; }
li { margin-top: 10px; }
li li { margin-left: 20px; }
ul, ol { margin-left: 0; padding-left: 0; }
h1, h2, h3, h4, h5, h6 { text-align: center; }
</style>
      </head>
<body>
    <main id="content">
        <h1 id="vanilla-js-drop-in-annotation-system">Vanilla JS Drop-in Annotation System</h1>
        <p>A zero-dependency, self-contained commenting and highlighting tool for any static HTML page. This system allows users to annotate text, auto-saves their comments locally, and lets them share their comments with others via compressed links or JSON files, all without requiring a server or external libraries.</p>
        <h2 id="core-features">Core Features</h2>
        <ul>
            <li><strong>Self-Contained:</strong> The entire system—HTML, CSS, and JavaScript—can be pasted into any existing static HTML file, right at the end. No external files, build systems, or anything else are needed.</li>
            <li><strong>Zero Dependencies:</strong> Written in modern, vanilla JavaScript. No need for jQuery, React, Vue, or any other framework.</li>
            <li><strong>Purely Client-Side:</strong> All data is processed and stored exclusively in the user's browser. No server is required, and no data is ever sent over the network, ensuring complete privacy.</li>
            <li><strong>Persistent Local Storage:</strong> Comments are automatically saved to the browser's <code>localStorage</code>, so they persist even after closing the tab or browser.</li>
            <li><strong>Robust Highlighting:</strong> The system can reliably highlight anything from text within an element to selections that span multiple elements, anywhere on the page.</li>
            <li><strong>Best-case Collaboration Features:</strong> When you import other people's comments, your own are preserved, and next time you export, the combined comments are exported together, allowing conversations (made easier with self-contained link sharing). Even better, the authorship of each comment is maintained, with different author names and associated colors (based on a hash function). On top of that, "resolve" functionality allows you to mark which comments you've delt with, without losing comment history.</li>
            <li><strong>Resilient Data Model:</strong> Annotations are saved using a precise DOM path, with a smart text-search fallback to ensure that comments can be imported and restored even if the underlying page structure has minor changes.</li>
            <li><strong>Two Ways to Share:</strong><ol>
            <li><strong>Shareable Links:</strong> Generates a compressed, URL-safe Base64 link that contains all comment data. Perfect for directly sharing an annotated version of the page.</li>
            <li><strong>Import/Export:</strong> Users can download their comments as a <code>.json</code> file for backup or sharing extremely large comment sets (over ~2,300 comments, which is the length at which Chrome stops displaying URL characters), and import files from others.</li>
            </ol>
            </li>
            <li><strong>Intuitive UI &amp; UX:</strong><ul>
            <li>An immersive UI that tries to remain as unobtrusive as possible.</li>
            <li>A central management widget that appears on hover.</li>
            <li>A complete comment list at the end of the document for easy navigation.</li>
            <li>Helpful keyboard shortcuts (<code>Shift+Enter</code> to comment/submit, <code>Esc</code> to cancel).</li>
            <li>Click-to-show tooltips with easy comment deletion.</li>
            <li>Fully responsive for both desktop and mobile use.</li>
            <li>Click on the management widget to jump to the next comment, to save you scrolling in long documents.</li>
            </ul>
            </li>
        </ul>
        <h2 id="installation">Installation</h2>
        <p>Adding this system to any existing HTML page is a simple three-step process:</p>
        <ol>
            <li><p><strong>Add the HTML:</strong> Copy the HTML for the UI elements and paste it right before the closing <code>&lt;/body&gt;</code> tag in your file. This includes the main UI container, the corner widget, and the comment summary section.</p>
            </li>
            <li><p><strong>Add the CSS:</strong> Copy the entire <code>&lt;style&gt;...&lt;/style&gt;</code> block and paste it inside your <code>&lt;head&gt;</code> tag or right before the HTML you just added.</p>
            </li>
            <li><p><strong>Add the JavaScript:</strong> Copy the entire final <code>&lt;script&gt;...&lt;/script&gt;</code> block and paste it at the very end of your file, right before the closing <code>&lt;/body&gt;</code> tag and after the UI HTML.</p>
            <p><strong>Important:</strong> The script initializes itself by targeting the element with the ID <code>content</code>. If your main text container has a different ID, simply change the last line of the script:</p>
            <pre><code class="lang-javascript"><span class="hljs-regexp">//</span> Change <span class="hljs-string">'content'</span> to the ID <span class="hljs-keyword">of</span> your main text container
<span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'DOMContentLoaded'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        initializeCommentingSystem(<span class="hljs-string">'your-content-id-here'</span>);
});
        </code></pre>
            </li>
        </ol>
        <p>That's it! Your page now has a complete annotation system.</p>
        <h2 id="how-it-works">How It Works</h2>
        <p>The system is designed for maximum resilience and portability.</p>
        <ul>
            <li><strong>Annotation Positioning:</strong> When a comment is created, the system saves the precise location of the highlight using a serialized DOM <code>Range</code>. This includes the node path from the root element and character offsets. When loading comments, it attempts to reconstruct this path.</li>
            <li><strong>Resilient Fallback:</strong> If a path cannot be found (due to minor HTML changes or browser parsing differences), the system intelligently falls back to searching for the highlight's saved text content within the expected area, dramatically increasing the durability of saved comments.</li>
            <li><strong>Shareable Link Compression:</strong> To avoid creating impractically long URLs, the "Copy Link" feature first compresses the entire JSON data of the comments using the browser's built-in Gzip compression stream before encoding it into a URL-safe Base64 string. This reduces the final data size by over 90%, making links practical for sharing.</li>
        </ul>
        <h2 id="vibe-coding-disclaimer">Vibe Coding Disclaimer</h2>
        <p>Usually even when I do AI-assisted coding I read every diff, design every architecture and algorithm decision before I even talk to the LLM, and I'm very careful and picky. I also use agentic coding systems to have tigher control over what they do, since every change is diffed. Not so here. I did this straight in a Gemini 2.5 Pro chat and literally didn't look at the code at all. So take that as you will. I'm not claiming this is my work, just that it's a really useful little tool for me, to replace the only thing I use Google Docs for, and someone might find it useful too.</p>
    </main>
<style>
 :root {
     --comment-highlight-bg: rgba(51, 255, 153, 0.4);
     --comment-ui-bg: #1a2a1a;
     --comment-ui-text: #e8f8e8;
     --comment-ui-accent: #33ff99;
     --comment-ui-border: #6a826a;
 }

 .comment-highlight {
     background-color: var(--comment-highlight-bg);
     border-bottom: 2px dashed var(--comment-ui-accent);
     cursor: pointer;
     color: inherit;
 }

 /* Main Comment Creation Drawer */
 #comment-ui-container {
     position: absolute;
     bottom: 0;
     left: 0;
     width: 100%;
     background-color: var(--comment-ui-bg);
     color: var(--comment-ui-text);
     box-shadow: 0 -2px 10px rgba(0,0,0,0.5);
     z-index: 10000;
     transform: translateY(100%);
     transition: transform 0.3s ease-in-out;
     padding: 1rem;
     box-sizing: border-box;
     display: flex;
     flex-direction: column;
     gap: 0.75rem;
     border-top: 1px solid var(--comment-ui-border);
 }

 #comment-ui-container.visible {
     transform: translateY(0);
 }

 #comment-ui-container button {
     background-color: var(--comment-ui-accent);
     color: var(--bg-color);
     font-weight: bold;
     border: none;
     padding: 0.6rem 1rem;
     border-radius: 5px;
     cursor: pointer;
     font-size: 0.9rem;
     font-family: sans-serif;
     text-align: center;
 }

 #comment-ui-container button.secondary {
     background-color: var(--comment-ui-border);
     color: var(--comment-ui-text);
     font-weight: normal;
 }

 #comment-ui-container button:hover {
     opacity: 0.85;
 }

 #comment-input-area {
     width: 100%;
     background-color: #0c140c;
     color: var(--comment-ui-text);
     border: 1px solid var(--comment-ui-border);
     border-radius: 5px;
     padding: 0.5rem;
     font-size: 1rem;
     font-family: sans-serif;
     min-height: 80px;
     box-sizing: border-box;
     resize: vertical;
 }

 #comment-form {
     display: none;
     flex-direction: column;
     gap: 0.75rem;
 }

 #comment-form .form-buttons {
     display: flex;
     gap: 0.5rem;
     justify-content: flex-end;
 }

 /* Tooltip */
 #comment-tooltip {
     position: absolute;
     display: none;
     background-color: var(--comment-ui-bg);
     color: var(--comment-ui-text);
     border: 1px solid var(--comment-ui-border);
     border-radius: 5px;
     padding: 0.8rem;
     max-width: 300px;
     font-size: 0.9rem;
     z-index: 10001;
     box-shadow: 0 4px 8px rgba(0,0,0,0.3);
     overflow-wrap: break-word;
     font-family: sans-serif;
     line-height: 1.5;
 }

 .delete-comment-btn {
     background: var(--comment-ui-border);
     color: var(--comment-ui-text);
     border: none;
     padding: 4px 8px;
     margin-top: 8px;
     border-radius: 3px;
     cursor: pointer;
     display: block;
     width: 100%;
     font-size: 0.8rem;
 }

 .delete-comment-btn:hover {
     background: #c13434;
 }

 /* Management Widget in Corner */
 #comment-widget-container {
     position: absolute;
     bottom: 15px;
     right: 15px;
     z-index: 9999;
     display: flex;
     flex-direction: column-reverse;
     align-items: flex-end;
 }

 #comment-counter {
     background-color: rgba(26, 42, 26, 0.8);
     backdrop-filter: blur(5px);
     color: var(--comment-ui-text);
     padding: 5px 12px;
     margin-top: 8px;
     border-radius: 15px;
     font-size: 0.85rem;
     font-family: sans-serif;
     display: none;
     box-shadow: 0 1px 4px rgba(0,0,0,0.4);
     border: 1px solid var(--comment-ui-border);
     cursor: default;
     transition: transform 0.2s ease-out;
 }

 #comment-management-wrapper {
     display: flex;
     flex-direction: column;
     align-items: flex-end;
     gap: 8px;
     opacity: 0;
     visibility: hidden;
     transform: translateY(10px);
     transition: all 0.2s ease-out;
 }

 #comment-management-flyout {
     display: flex;
     gap: 0.5rem;
     padding: 8px;
     background-color: rgba(26, 42, 26, 0.9);
     backdrop-filter: blur(5px);
     border: 1px solid var(--comment-ui-border);
     border-radius: 8px;
 }

 #comment-management-help-text {
     color: var(--comment-ui-border);
     font-size: 0.75rem;
     font-family: sans-serif;
     text-align: right;
     padding: 0 4px;
     max-width: 250px;
 }

 #comment-widget-container:hover #comment-management-wrapper {
     opacity: 1;
     visibility: visible;
     transform: translateY(0);
 }

 #comment-widget-container:hover #comment-counter {
     transform: scale(1.05);
 }

 #comment-management-flyout button,
 #comment-management-flyout .file-input-label {
     background-color: var(--comment-ui-accent);
     color: var(--bg-color);
     font-weight: bold;
     border: none;
     padding: 0.5rem 0.8rem;
     border-radius: 5px;
     cursor: pointer;
     font-size: 0.8rem;
     font-family: sans-serif;
     white-space: nowrap;
     display: flex;
     align-items: center;
     justify-content: center;
 }

 #comment-management-flyout button.secondary {
     background-color: var(--comment-ui-border);
     color: var(--comment-ui-text);
     font-weight: normal;
 }

 #comment-management-flyout button:hover,
 #comment-management-flyout .file-input-label:hover {
     opacity: 0.85;
 }

 #copy-link-btn {
     background-color: #4A5D4A;
 }

 #import-comments-input {
     display: none;
 }

 /* Help Text and Keybinding Styles */
 .comment-help-text {
     font-size: 0.8rem;
     color: var(--comment-ui-border);
     text-align: center;
     width: 100%;
 }

 .comment-help-text kbd {
     background-color: #0c140c;
     border: 1px solid var(--comment-ui-border);
     padding: 2px 6px;
     border-radius: 4px;
     font-family: monospace;
     font-size: 0.75rem;
 }

 /* Comment Summary Section Styles */
 #comment-summary-section {
     max-width: 60em;
     margin: 5em auto;
     padding: 2em;
     border-top: 2px solid var(--comment-ui-border);
     color: var(--comment-ui-text);
 }

 #comment-summary-section h2 {
     font-family: var(--font-heading);
     color: var(--comment-ui-accent);
     text-transform: uppercase;
     margin-top: 0;
     border-bottom: none;
     margin-bottom: 1em;
 }

 #comment-summary-list {
     list-style: none;
     padding: 0;
     margin: 0;
 }

 #comment-summary-list li {
     padding: 1.5em;
     border-bottom: 1px solid var(--comment-ui-border);
     cursor: pointer;
     transition: background-color 0.2s ease;
     position: relative;
 }

 #comment-summary-list li:hover {
     background-color: var(--comment-ui-bg);
 }

 #comment-summary-list li blockquote {
     margin: 0 0 0.5em 0;
     padding-left: 1em;
     border-left: 3px solid var(--comment-ui-accent);
     color: var(--comment-ui-text);
     font-style: italic;
     opacity: 0.8;
 }

 #comment-summary-list li p {
     margin: 0;
     color: var(--comment-ui-text);
     font-family: sans-serif;
 }

 .summary-delete-btn {
     position: absolute;
     top: 5px;
     right: 5px;
     font-size: 1.5rem;
     color: var(--comment-ui-border);
     transition: color 0.2s ease;
     line-height: 1;
     padding: 10px;
 }

 .summary-delete-btn:hover {
     color: #c13434;
 }

 /* Mobile Responsiveness */
 @media (min-width: 600px) {
     #comment-ui-container {
         width: 500px;
         max-width: 90%;
         left: 50%;
         transform: translateX(-50%) translateY(120%);
         border-top-left-radius: 8px;
         border-top-right-radius: 8px;
     }

     #comment-ui-container.visible {
         transform: translateX(-50%) translateY(0);
     }
 }

 /* Style for Resolve button in tooltip and summary */
 .resolve-comment-btn {
     background-color: var(--comment-ui-accent);
     color: var(--bg-color);
     font-weight: bold;
     border: none;
     padding: 4px 8px;
     margin-top: 8px;
     margin-right: 5px;
     border-radius: 3px;
     cursor: pointer;
     font-size: 0.8rem;
 }

 .resolve-comment-btn:hover {
     opacity: 0.85;
 }

 .summary-unresolve-btn {
     background-color: var(--comment-ui-accent);
     color: var(--bg-color);
     font-weight: bold;
     border: none;
     padding: 6px 12px;
     border-radius: 4px;
     cursor: pointer;
     font-size: 0.85rem;
     margin-top: 10px;
     display: inline-block;
 }

 .summary-unresolve-btn:hover {
     opacity: 0.85;
 }

 /* Make the counter look clickable */
 #comment-counter.has-comments {
     cursor: pointer;
 }

 /* Author Attribution Styles */
 .comment-author {
     display: block;
     font-size: 0.8rem;
     font-weight: bold;
     opacity: 0.7;
     margin-bottom: 0.5em;
 }

 #comment-tooltip .comment-author {
     color: var(--comment-ui-accent);
 }

 .summary-author {
     font-weight: bold;
     margin-bottom: 0.5em;
     font-family: sans-serif;
     font-size: 0.9em;
 }

 /* Sandboxed Root Container */
 #commenting-system-root {
     position: fixed;
     top: 0;
     left: 0;
     width: 100%;
     height: 100%;
     z-index: 2147483647;
     pointer-events: none;
     font-family: sans-serif;
     font-size: 16px;
     line-height: 1.5;
 }

 #commenting-system-root > * {
     pointer-events: auto;
 }
</style>

<div id="commenting-system-root">
    <div id="comment-tooltip"></div>

    <div id="comment-widget-container">
        <div id="comment-counter"></div>
        <div id="comment-management-wrapper">
            <div id="comment-management-flyout">
                <button id="copy-link-btn">Copy Link</button>
                <label for="import-comments-input" class="file-input-label">Import</label>
                <input type="file" id="import-comments-input" accept=".json"/>
                <button id="export-comments-btn">Export</button>
                <button id="clear-comments-btn" class="secondary">Clear All</button>
            </div>
            <small id="comment-management-help-text">
                Comments are stored locally in your browser. Use Export/Import or Copy Link to share.
            </small>
        </div>
    </div>

    <div id="comment-ui-container">
        <button id="add-comment-btn" style="display: none;">Add Comment</button>
        <div id="add-comment-help-text" class="comment-help-text" style="display: none;">
            Press <kbd>Shift</kbd> + <kbd>Enter</kbd> to add comment
        </div>
        <form id="comment-form">
            <textarea id="comment-input-area" placeholder="Type your comment here..."></textarea>
            <div class="comment-help-text">
                <kbd>Shift</kbd> + <kbd>Enter</kbd> to save, <kbd>Esc</kbd> to cancel
            </div>
            <div class="form-buttons">
                <button type="button" id="cancel-comment-btn" class="secondary">Cancel</button>
                <button type="submit" id="save-comment-btn">Save</button>
            </div>
        </form>
    </div>
</div>

<section id="comment-summary-section" style="display: none;">
    <h2>Comment Summary</h2>
    <ol id="comment-summary-list"></ol>
</section>

<script>
 window.commentingSystemInitialized = false;

 window.initializeCommentingSystem = function(rootElementId) {
     if (window.commentingSystemInitialized) {
         console.warn("Commenting system has already been initialized. Aborting.");
         return;
     }

     // State management
     let comments = [];
     let currentUser = 'Anonymous';
     let nextHighlightIndex = 0;
     let currentSelectionData = null;

     // DOM elements
     const commentingRoot = document.getElementById('commenting-system-root');
     const commentWidgetContainer = document.getElementById('comment-widget-container');
     const commentContainer = document.getElementById('comment-ui-container');
     const addCommentBtn = document.getElementById('add-comment-btn');
     const addCommentHelpText = document.getElementById('add-comment-help-text');
     const commentForm = document.getElementById('comment-form');
     const commentInput = document.getElementById('comment-input-area');
     const exportBtn = document.getElementById('export-comments-btn');
     const importInput = document.getElementById('import-comments-input');
     const clearBtn = document.getElementById('clear-comments-btn');
     const copyLinkBtn = document.getElementById('copy-link-btn');
     const tooltip = document.getElementById('comment-tooltip');
     const commentCounter = document.getElementById('comment-counter');
     const commentSummarySection = document.getElementById('comment-summary-section');
     const commentSummaryList = document.getElementById('comment-summary-list');
     const contentRoot = document.getElementById(rootElementId) || document.body;

     // URL data handling & compression helpers
     const toUrlSafeBase64 = (buffer) => {
         return btoa(String.fromCharCode.apply(null, new Uint8Array(buffer)))
             .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
     };

     const fromUrlSafeBase64 = (str) => {
         str = str.replace(/-/g, '+').replace(/_/g, '/');
         while (str.length % 4) { str += '='; }
         const binaryString = atob(str);
         const bytes = new Uint8Array(binaryString.length);
         for (let i = 0; i < binaryString.length; i++) {
             bytes[i] = binaryString.charCodeAt(i);
         }
         return bytes.buffer;
     };

     const compressData = async (data) => {
         const stream = new Blob([JSON.stringify(data)], { type: 'application/json' })
             .stream().pipeThrough(new CompressionStream('gzip'));
         return await new Response(stream).arrayBuffer();
     };

     const decompressData = async (compressedBuffer) => {
         try {
             const stream = new Blob([compressedBuffer], { type: 'application/gzip' })
                 .stream().pipeThrough(new DecompressionStream('gzip'));
             const decompressed = await new Response(stream).json();
             return decompressed;
         } catch (e) {
             console.error("Decompression failed:", e);
             return null;
         }
     };

     // Core functions
     const syncRootWithViewport = () => {
         if (!window.visualViewport) return;

         const { offsetTop, offsetLeft, width, height } = window.visualViewport;
         const trueTop = offsetTop + window.scrollY;
         const trueLeft = offsetLeft + window.scrollX;

         commentingRoot.style.transform = `translate(${trueLeft}px, ${trueTop}px)`;
         commentingRoot.style.width = `${width}px`;
         commentingRoot.style.height = `${height}px`;
     };

     const initializeViewportPositioning = () => {
         const isMobileLike = navigator.maxTouchPoints > 0;

         if (isMobileLike && window.visualViewport) {
             console.log("Touch device detected. Upgrading to JS-driven positioning for reliability.");
             commentingRoot.style.position = 'absolute';
             window.visualViewport.addEventListener('resize', syncRootWithViewport);
             window.visualViewport.addEventListener('scroll', syncRootWithViewport);
             syncRootWithViewport();
         }
     };

     const getNodePath = (node) => {
         const path = [];
         while (node !== contentRoot && node) {
             let sibling = node; let index = 0;
             while ((sibling = sibling.previousSibling) != null) { index++; }
             path.unshift(index);
             node = node.parentNode;
         }
         return path;
     };

     const getNodeFromPath = (path) => {
         let node = contentRoot;
         for (const index of path) {
             if (node && node.childNodes[index]) {
                 node = node.childNodes[index];
             } else { return null; }
         }
         return node;
     };

     const getOrSetUser = () => {
         const savedUser = localStorage.getItem('commentingUser');
         if (savedUser) {
             currentUser = savedUser;
             return;
         }
         const newUser = prompt("Please enter your name or initials for commenting:", "Anonymous");
         if (newUser && newUser.trim() !== "") {
             currentUser = newUser.trim();
         } else {
             currentUser = 'Anonymous';
         }
         localStorage.setItem('commentingUser', currentUser);
     };

     const getAuthorColor = (author) => {
         if (!author) return 'rgba(51, 255, 153, 0.4)';
         let hash = 0;
         for (let i = 0; i < author.length; i++) {
             hash = author.charCodeAt(i) + ((hash << 5) - hash);
         }
         const h = hash % 360;
         return {
             border: `hsl(${h}, 70%, 40%)`,
             background: `hsla(${h}, 70%, 85%, 0.4)`
         };
     };

     const serializeRange = (range) => {
         if (!range) return null;
         return {
             startPath: getNodePath(range.startContainer),
             startOffset: range.startOffset,
             endPath: getNodePath(range.endContainer),
             endOffset: range.endOffset,
             text: range.toString()
         };
     };

     const deserializeRange = (savedRange) => {
         const startContainer = getNodeFromPath(savedRange.startPath);
         const endContainer = getNodeFromPath(savedRange.endPath);
         if (startContainer && endContainer) {
             try {
                 const range = document.createRange();
                 const startOffset = Math.min(savedRange.startOffset, startContainer.textContent.length);
                 const endOffset = Math.min(savedRange.endOffset, endContainer.textContent.length);
                 range.setStart(startContainer, startOffset);
                 range.setEnd(endContainer, endOffset);
                 return range;
             } catch (e) { console.error("Error setting range from path, falling back.", e, savedRange); }
         }
         console.warn("Path failed for highlight. Falling back to text search for:", savedRange.text);
         const normalizedText = savedRange.text.replace(/\s+/g, ' ').trim();
         if (!normalizedText) return null;
         const walker = document.createTreeWalker(contentRoot, NodeFilter.SHOW_TEXT);
         let node;
         while (node = walker.nextNode()) {
             const normalizedNodeText = node.nodeValue.replace(/\s+/g, ' ');
             const index = normalizedNodeText.indexOf(normalizedText);
             if (index !== -1) {
                 const range = document.createRange();
                 range.setStart(node, index);
                 range.setEnd(node, index + normalizedText.length);
                 return range;
             }
         }
         console.error("Could not find text for highlight anywhere on the page:", savedRange);
         return null;
     };

     const renderCommentSummary = () => {
         commentSummaryList.innerHTML = '';
         if (comments.length === 0) {
             commentSummarySection.style.display = 'none';
             return;
         }
         commentSummarySection.style.display = 'block';

         const commentsWithElements = comments.map(comment => ({
             comment,
             el: document.querySelector(`.comment-highlight[data-comment-id="${comment.id}"]`)
         }));

         commentsWithElements.sort((a, b) => {
             if (a.comment.isResolved && !b.comment.isResolved) return 1;
             if (!a.comment.isResolved && b.comment.isResolved) return -1;
             if (!a.el || !b.el) return 0;
             return a.el.offsetTop - b.el.offsetTop;
         });

         commentsWithElements.forEach(({ comment }) => {
             const li = document.createElement('li');
             li.dataset.commentId = comment.id;
             const authorName = comment.author || 'Anonymous';
             const authorColors = getAuthorColor(authorName);

             const authorEl = document.createElement('div');
             authorEl.className = 'summary-author';
             authorEl.textContent = `By: ${authorName}`;
             authorEl.style.color = authorColors.border;

             const deleteBtn = document.createElement('span');
             deleteBtn.className = 'summary-delete-btn';
             deleteBtn.innerHTML = '&times;';
             deleteBtn.dataset.commentId = comment.id;

             const blockquote = document.createElement('blockquote');
             const quoteText = comment.range.text.length > 100 ? comment.range.text.substring(0, 97) + '...' : comment.range.text;
             blockquote.textContent = quoteText;
             blockquote.style.borderLeftColor = authorColors.border;

             const p = document.createElement('p');
             p.textContent = comment.text;

             li.appendChild(deleteBtn);
             li.appendChild(authorEl);
             li.appendChild(blockquote);
             li.appendChild(p);

             if (comment.isResolved) {
                 li.classList.add('resolved');
                 const unresolveBtn = document.createElement('button');
                 unresolveBtn.className = 'summary-unresolve-btn';
                 unresolveBtn.textContent = 'Unresolve';
                 unresolveBtn.dataset.commentId = comment.id;
                 li.appendChild(unresolveBtn);
             }

             commentSummaryList.appendChild(li);
         });
     };

     const getLastHighlightScrollPercent = () => {
         const highlights = Array.from(document.querySelectorAll('.comment-highlight'));
         if (highlights.length === 0) return null;
         const lastHighlight = highlights.reduce((last, current) => current.offsetTop > last.offsetTop ? current : last);
         const docHeight = document.documentElement.scrollHeight;
         const viewportHeight = window.innerHeight;
         const scrollableHeight = docHeight - viewportHeight;
         if (scrollableHeight <= 0) return 100;
         const percentage = (lastHighlight.offsetTop / scrollableHeight) * 100;
         return Math.min(100, Math.round(percentage));
     };

     const updateCounter = (placementErrors = 0) => {
         const totalCount = comments.length;
         const placedCount = totalCount - placementErrors;
         const hasVisibleHighlights = document.querySelector('.comment-highlight') !== null;

         if (hasVisibleHighlights) {
             commentCounter.classList.add('has-comments');
         } else {
             commentCounter.classList.remove('has-comments');
         }

         if (totalCount === 0) {
             commentCounter.textContent = 'No Comments';
             commentCounter.title = '';
             commentCounter.style.display = 'block';
             return;
         }

         const percentage = getLastHighlightScrollPercent();
         let text;

         if (placedCount > 0) {
             text = `${placedCount} Comment${placedCount !== 1 ? 's' : ''}`;
             if (percentage !== null) {
                 text += ` (${percentage}%)`;
             }
         } else {
             text = '0 Comments Placed';
         }

         if (placementErrors > 0) {
             commentCounter.title = `${placementErrors} comment(s) could not be found on the page.`;
         } else {
             commentCounter.title = '';
         }

         commentCounter.textContent = text;
         commentCounter.style.display = 'block';
     };

     const applyHighlight = (range, commentId) => {
         if (!range || range.collapsed) return;
         const comment = comments.find(c => c.id === commentId);
         const authorColors = getAuthorColor(comment ? comment.author : null);

         try {
             const marker = document.createElement('mark');
             marker.className = 'comment-highlight';
             marker.dataset.commentId = commentId;
             marker.style.backgroundColor = authorColors.background;
             marker.style.borderBottomColor = authorColors.border;
             range.surroundContents(marker);
             addHighlightEventListeners(marker);
         } catch (e) {
             console.warn("surroundContents failed, likely a multi-element selection. Using robust fallback.", e);
             const walker = document.createTreeWalker(range.commonAncestorContainer, NodeFilter.SHOW_TEXT);
             const textNodes = [];
             while(walker.nextNode()) {
                 if(range.intersectsNode(walker.currentNode)) { textNodes.push(walker.currentNode); }
             }
             for (const node of textNodes) {
                 const highlightRange = document.createRange();
                 highlightRange.setStart(node, node === range.startContainer ? range.startOffset : 0);
                 highlightRange.setEnd(node, node === range.endContainer ? range.endOffset : node.textContent.length);
                 if (!highlightRange.collapsed) {
                     const marker = document.createElement('mark');
                     marker.className = 'comment-highlight';
                     marker.dataset.commentId = commentId;
                     marker.style.backgroundColor = authorColors.background;
                     marker.style.borderBottomColor = authorColors.border;
                     highlightRange.surroundContents(marker);
                     addHighlightEventListeners(marker);
                 }
             }
         }
     };

     const saveCommentsToLocal = () => {
         try { localStorage.setItem('userComments', JSON.stringify(comments)); }
         catch (e) { console.error("Could not save comments to localStorage.", e); }
     };

     const applyAllHighlights = (commentsToApply) => {
         let placementErrors = 0;
         const itemsWithRanges = commentsToApply.map(comment => {
             const range = deserializeRange(comment.range);
             if (!range) { placementErrors++; }
             return { comment, range };
         });
         itemsWithRanges.sort((a, b) => {
             if (!a.range || !b.range) return 0;
             return b.range.compareBoundaryPoints(Range.START_TO_START, a.range);
         });
         for (const item of itemsWithRanges) {
             if (item.range && !item.comment.isResolved) {
                 try {
                     applyHighlight(item.range, item.comment.id);
                 } catch (e) {
                     console.error("Failed to apply a highlight during import:", item.comment, e);
                 }
             }
         }
         return placementErrors;
     };

     const loadInitialComments = async () => {
         const hash = window.location.hash.slice(1);
         if (hash) {
             console.log("Loading comments from URL...");
             try {
                 const buffer = fromUrlSafeBase64(hash);
                 const data = await decompressData(buffer);
                 if (data && Array.isArray(data)) {
                     comments = data.map(comment => ({
                         ...comment,
                         id: `comment-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
                     }));
                     applyAllHighlights(comments);
                     saveCommentsToLocal();
                     history.replaceState(null, '', window.location.pathname + window.location.search);
                 }
             } catch (e) {
                 console.error("Failed to load comments from URL:", e);
                 loadCommentsFromLocal();
             }
         } else {
             console.log("Loading comments from localStorage...");
             const savedCommentsJSON = localStorage.getItem('userComments');
             if (savedCommentsJSON) {
                 try {
                     const savedComments = JSON.parse(savedCommentsJSON);
                     if (Array.isArray(savedComments)) {
                         comments = savedComments;
                         applyAllHighlights(comments);
                     }
                 } catch (e) {
                     console.error("Could not parse comments from localStorage.", e);
                     localStorage.removeItem('userComments');
                 }
             }
         }
         updateCounter();
         renderCommentSummary();
     };

     const deleteComment = (commentId) => {
         if (!confirm('Are you sure you want to delete this comment?')) return;
         const commentIndex = comments.findIndex(c => c.id === commentId);
         if (commentIndex > -1) {
             comments.splice(commentIndex, 1);
             saveCommentsToLocal();
             document.querySelectorAll(`.comment-highlight[data-comment-id="${commentId}"]`).forEach(removeHighlight);
             updateCounter();
             hideTooltip();
             renderCommentSummary();
         }
     };

     const resolveComment = (commentId) => {
         const comment = comments.find(c => c.id === commentId);
         if (comment) {
             comment.isResolved = true;
             saveCommentsToLocal();
             const highlightEl = document.querySelector(`.comment-highlight[data-comment-id="${commentId}"]`);
             if (highlightEl) {
                 removeHighlight(highlightEl);
             }
             hideTooltip();
             renderCommentSummary();
         }
     };

     const unresolveComment = (commentId) => {
         const comment = comments.find(c => c.id === commentId);
         if (comment) {
             comment.isResolved = false;
             saveCommentsToLocal();
             const range = deserializeRange(comment.range);
             if (range) {
                 applyHighlight(range, comment.id);
             }
             renderCommentSummary();
         }
     };

     const showTooltip = (highlightEl) => {
         const commentId = highlightEl.dataset.commentId;
         const comment = comments.find(c => c.id === commentId);
         if (!comment) return;
         const authorName = comment.author || 'Anonymous';

         tooltip.innerHTML = `
             <small class="comment-author">By: ${authorName}</small>
             <span>${comment.text.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</span>
             <br/>
             <button class="resolve-comment-btn" data-comment-id="${commentId}">Resolve</button>
             <button class="delete-comment-btn" data-comment-id="${commentId}">Delete</button>
         `;
         tooltip.querySelector('.resolve-comment-btn').addEventListener('click', (e) => {
             e.stopPropagation();
             resolveComment(e.target.dataset.commentId);
         });
         tooltip.querySelector('.delete-comment-btn').addEventListener('click', (e) => {
             e.stopPropagation();
             deleteComment(e.target.dataset.commentId);
         });

         // --- START OF POSITIONING LOGIC ---

         // Reset display and position before calculating size
         tooltip.style.display = 'block';
         tooltip.style.left = '0px';
         tooltip.style.top = '0px';
         tooltip.dataset.activeCommentId = commentId;

         // Get the position of the highlight AND the tooltip's own size
         const highlightRect = highlightEl.getBoundingClientRect();
         const tooltipRect = tooltip.getBoundingClientRect();
         const viewportWidth = window.innerWidth;
         const viewportHeight = window.innerHeight;

         // 1. Calculate horizontal position
         let newLeft = highlightRect.left;
         // Check if it overflows the right edge of the viewport
         if (newLeft + tooltipRect.width > viewportWidth) {
             newLeft = viewportWidth - tooltipRect.width - 10; // Add 10px padding
         }
         // Ensure it doesn't go off the left edge
         if (newLeft < 0) {
             newLeft = 10;
         }

         // 2. Calculate vertical position (try below first)
         let newTop = highlightRect.bottom + 5; // 5px margin below the highlight
         // Check if it overflows the bottom edge of the viewport
         if (newTop + tooltipRect.height > viewportHeight) {
             // If it overflows, flip it to be above the highlight instead
             newTop = highlightRect.top - tooltipRect.height - 5; // 5px margin above
         }
         // As a final fallback, ensure it's not off the top of the screen
         if (newTop < 0) {
             newTop = 10;
         }

         // 3. Apply the final calculated positions
         tooltip.style.left = `${newLeft}px`;
         tooltip.style.top = `${newTop}px`;

         // --- END OF POSITIONING LOGIC ---
     };

     const hideTooltip = () => {
         tooltip.style.display = 'none';
         tooltip.dataset.activeCommentId = '';
     };

     const addHighlightEventListeners = (marker) => {
         marker.addEventListener('click', (e) => {
             e.stopPropagation();
             if (tooltip.dataset.activeCommentId === marker.dataset.commentId) {
                 hideTooltip();
             } else {
                 showTooltip(marker);
             }
         });
     };

     const removeHighlight = (el) => {
         const parent = el.parentNode;
         if (parent) {
             while (el.firstChild) {
                 parent.insertBefore(el.firstChild, el);
             }
             parent.removeChild(el);
         }
     };

     const resetUI = () => {
         commentContainer.classList.remove('visible');
         addCommentBtn.style.display = 'none';
         addCommentHelpText.style.display = 'none';
         commentForm.style.display = 'none';
         commentInput.value = '';
         currentSelectionData = null;
     };

     const handleSelectionEnd = (e) => {
         if (commentContainer.contains(e.target) || e.target.closest('.comment-highlight') || e.target.closest('#comment-widget-container')) return;
         setTimeout(() => {
             const selection = window.getSelection();
             if (selection && !selection.isCollapsed && selection.rangeCount > 0) {
                 if (contentRoot.contains(selection.anchorNode) && contentRoot.contains(selection.focusNode)) {
                     commentContainer.classList.add('visible');
                     addCommentBtn.style.display = 'block';
                     addCommentHelpText.style.display = 'block';
                     commentForm.style.display = 'none';
                 }
             } else {
                 if (document.activeElement !== commentInput) resetUI();
             }
         }, 10);
     };

     contentRoot.addEventListener('mouseup', handleSelectionEnd);
     contentRoot.addEventListener('touchend', handleSelectionEnd);

     addCommentBtn.addEventListener('click', () => {
         getOrSetUser();
         const selection = window.getSelection();
         if (selection && !selection.isCollapsed) {
             currentSelectionData = serializeRange(selection.getRangeAt(0));
             addCommentBtn.style.display = 'none';
             addCommentHelpText.style.display = 'none';
             commentForm.style.display = 'flex';
             commentInput.focus();
         } else { resetUI(); }
     });

     document.getElementById('cancel-comment-btn').addEventListener('click', () => {
         resetUI();
         if (window.getSelection) window.getSelection().removeAllRanges();
     });

     commentForm.addEventListener('submit', (e) => {
         e.preventDefault();
         const commentText = commentInput.value.trim();
         if (commentText && currentSelectionData) {
             const rangeToHighlight = deserializeRange(currentSelectionData);
             if (!rangeToHighlight) { resetUI(); return; }
             const newComment = {
                 id: `comment-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                 text: commentText,
                 range: currentSelectionData,
                 author: currentUser,
                 isResolved: false
             };
             comments.push(newComment);
             saveCommentsToLocal();
             applyHighlight(rangeToHighlight, newComment.id);
             resetUI();
             updateCounter();
             renderCommentSummary();
             if (window.getSelection) window.getSelection().removeAllRanges();
         }
     });

     commentInput.addEventListener('focus', () => { document.body.style.overflow = 'hidden'; });
     commentInput.addEventListener('blur', () => { document.body.style.overflow = ''; });

     commentInput.addEventListener('keydown', (e) => {
         if (e.key === 'Enter' && e.shiftKey) { e.preventDefault(); commentForm.requestSubmit(); }
         if (e.key === 'Escape') {
             e.preventDefault();
             resetUI();
             if (window.getSelection) window.getSelection().removeAllRanges();
         }
     });

     exportBtn.addEventListener('click', () => {
         if (comments.length === 0) { return; }
         const dataStr = JSON.stringify(comments, null, 2);
         const dataBlob = new Blob([dataStr], { type: 'application/json' });
         const url = URL.createObjectURL(dataBlob);
         const a = document.createElement('a'); a.href = url; a.download = 'comments.json';
         document.body.appendChild(a); a.click(); document.body.removeChild(a);
         URL.revokeObjectURL(url);
     });

     importInput.addEventListener('change', (e) => {
         const file = e.target.files[0];
         if (!file) return;
         const reader = new FileReader();
         reader.onload = (event) => {
             try {
                 const importedComments = JSON.parse(event.target.result);
                 if (Array.isArray(importedComments)) {
                     const existingIds = new Set(comments.map(c => c.id));
                     let newCommentsAdded = 0;

                     importedComments.forEach(importedComment => {
                         if (!importedComment || !importedComment.range) {
                             console.warn("Skipping invalid comment object during import:", importedComment);
                             return;
                         }

                         if (!importedComment.id) {
                             importedComment.id = `comment-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                         }

                         if (!existingIds.has(importedComment.id)) {
                             comments.push(importedComment);
                             newCommentsAdded++;
                         }
                     });

                     if (newCommentsAdded > 0) {
                         document.querySelectorAll('.comment-highlight').forEach(removeHighlight);
                         const placementErrors = applyAllHighlights(comments);
                         saveCommentsToLocal();
                         updateCounter(placementErrors);
                         renderCommentSummary();
                         alert(`${newCommentsAdded} new comment(s) were successfully imported and merged.`);
                     } else {
                         alert("No new comments were found in the imported file.");
                     }
                 }
             } catch (err) {
                 console.error(err);
                 alert('Error: Could not parse the JSON file.');
             }
         };
         reader.readAsText(file);
         e.target.value = '';
     });

     copyLinkBtn.addEventListener('click', async () => {
         if (comments.length === 0) return;
         const originalText = copyLinkBtn.textContent;
         copyLinkBtn.textContent = 'Compressing...';
         copyLinkBtn.disabled = true;

         try {
             const lightweightComments = comments.map(({ text, range, author }) => ({ text, range, author }));

             const compressed = await compressData(lightweightComments);
             const base64 = toUrlSafeBase64(compressed);
             const url = new URL(window.location);
             url.hash = base64;

             const URL_LENGTH_LIMIT = 37000;
             if (url.href.length > URL_LENGTH_LIMIT) {
                 alert("Warning: The generated link is very long and may not work in all browsers or applications.\n\nExporting a JSON file is recommended for many comments.");
             }

             await navigator.clipboard.writeText(url.href);
             copyLinkBtn.textContent = 'Copied!';
         } catch (err) {
             console.error("Failed to copy link:", err);
             copyLinkBtn.textContent = 'Error!';
         } finally {
             setTimeout(() => {
                 copyLinkBtn.textContent = originalText;
                 copyLinkBtn.disabled = false;
             }, 2000);
         }
     });

     document.addEventListener('click', (e) => {
         if (!e.target.closest('.comment-highlight') && !e.target.closest('#comment-tooltip')) {
             hideTooltip();
         }
     });

     document.addEventListener('keydown', (e) => {
         if (e.key === 'Enter' && e.shiftKey && document.activeElement !== commentInput) {
             if (addCommentBtn.style.display === 'block') {
                 e.preventDefault();
                 addCommentBtn.click();
             }
         }
     });

     commentSummaryList.addEventListener('click', (e) => {
         const deleteButton = e.target.closest('.summary-delete-btn');
         const unresolveButton = e.target.closest('.summary-unresolve-btn');

         if (deleteButton) {
             e.stopPropagation();
             deleteComment(deleteButton.dataset.commentId);
             return;
         }

         if (unresolveButton) {
             e.stopPropagation();
             unresolveComment(unresolveButton.dataset.commentId);
             return;
         }

         const li = e.target.closest('li');
         if (li && li.dataset.commentId && !li.classList.contains('resolved')) {
             const commentId = li.dataset.commentId;
             const highlightElement = document.querySelector(`.comment-highlight[data-comment-id="${commentId}"]`);
             if (highlightElement) {
                 highlightElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                 setTimeout(() => { showTooltip(highlightElement); }, 300);
             }
         }
     });

     commentWidgetContainer.addEventListener('click', (e) => {
         if (e.target.closest('#comment-management-flyout')) {
             return;
         }

         const highlights = Array.from(document.querySelectorAll('.comment-highlight'))
                                 .sort((a, b) => a.offsetTop - b.offsetTop);

         if (highlights.length === 0) {
             nextHighlightIndex = 0;
             return;
         }

         if (nextHighlightIndex >= highlights.length) {
             nextHighlightIndex = 0;
         }

         const nextHighlight = highlights[nextHighlightIndex];

         if (nextHighlight) {
             nextHighlight.scrollIntoView({ behavior: 'smooth', block: 'center' });
             setTimeout(() => { showTooltip(nextHighlight); }, 300);
         }

         nextHighlightIndex = (nextHighlightIndex + 1) % highlights.length;
     });

     clearBtn.addEventListener('click', () => {
         if (confirm('Are you sure you want to permanently delete all comments from this page? This will reload the page.')) {
             localStorage.removeItem('userComments');
             history.replaceState(null, '', window.location.pathname + window.location.search);
             location.reload();
         }
     });

     initializeViewportPositioning();
     loadInitialComments();

     window.commentingSystemInitialized = true;
     console.log("Commenting system initialized successfully.");
 };

 document.addEventListener('DOMContentLoaded', () => {
     initializeCommentingSystem('content');
 });
</script>
    
</body>
</html>
