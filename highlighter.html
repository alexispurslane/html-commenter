<style>
 :root {
     --comment-highlight-bg: rgba(51, 255, 153, 0.4);
     --comment-ui-bg: #1a2a1a;
     --comment-ui-text: #e8f8e8;
     --comment-ui-accent: #33ff99;
     --comment-ui-border: #6a826a;
 }

 .comment-highlight {
     background-color: var(--comment-highlight-bg);
     border-bottom: 2px dashed var(--comment-ui-accent);
     cursor: pointer;
     color: inherit;
 }

 /* Main Comment Creation Drawer */
 #comment-ui-container {
     position: absolute;
     bottom: 0;
     left: 0;
     width: 100%;
     background-color: var(--comment-ui-bg);
     color: var(--comment-ui-text);
     box-shadow: 0 -2px 10px rgba(0,0,0,0.5);
     z-index: 10000;
     transform: translateY(100%);
     transition: transform 0.3s ease-in-out;
     padding: 1rem;
     box-sizing: border-box;
     display: flex;
     flex-direction: column;
     gap: 0.75rem;
     border-top: 1px solid var(--comment-ui-border);
 }

 #comment-ui-container.visible {
     transform: translateY(0);
 }

 #comment-ui-container button {
     background-color: var(--comment-ui-accent);
     color: var(--bg-color);
     font-weight: bold;
     border: none;
     padding: 0.6rem 1rem;
     border-radius: 5px;
     cursor: pointer;
     font-size: 0.9rem;
     font-family: sans-serif;
     text-align: center;
 }

 #comment-ui-container button.secondary {
     background-color: var(--comment-ui-border);
     color: var(--comment-ui-text);
     font-weight: normal;
 }

 #comment-ui-container button:hover {
     opacity: 0.85;
 }

 #comment-input-area {
     width: 100%;
     background-color: #0c140c;
     color: var(--comment-ui-text);
     border: 1px solid var(--comment-ui-border);
     border-radius: 5px;
     padding: 0.5rem;
     font-size: 1rem;
     font-family: sans-serif;
     min-height: 80px;
     box-sizing: border-box;
     resize: vertical;
 }

 #comment-form {
     display: none;
     flex-direction: column;
     gap: 0.75rem;
 }

 #comment-form .form-buttons {
     display: flex;
     gap: 0.5rem;
     justify-content: flex-end;
 }

 /* Tooltip */
 #comment-tooltip {
     position: absolute;
     display: none;
     background-color: var(--comment-ui-bg);
     color: var(--comment-ui-text);
     border: 1px solid var(--comment-ui-border);
     border-radius: 5px;
     padding: 0.8rem;
     max-width: 300px;
     font-size: 0.9rem;
     z-index: 10001;
     box-shadow: 0 4px 8px rgba(0,0,0,0.3);
     overflow-wrap: break-word;
     font-family: sans-serif;
     line-height: 1.5;
 }

 .delete-comment-btn {
     background: var(--comment-ui-border);
     color: var(--comment-ui-text);
     border: none;
     padding: 4px 8px;
     margin-top: 8px;
     border-radius: 3px;
     cursor: pointer;
     display: block;
     width: 100%;
     font-size: 0.8rem;
 }

 .delete-comment-btn:hover {
     background: #c13434;
 }

 /* Management Widget in Corner */
 #comment-widget-container {
     position: absolute;
     bottom: 15px;
     right: 15px;
     z-index: 9999;
     display: flex;
     flex-direction: column-reverse;
     align-items: flex-end;
 }

 #comment-counter {
     background-color: rgba(26, 42, 26, 0.8);
     backdrop-filter: blur(5px);
     color: var(--comment-ui-text);
     padding: 5px 12px;
     margin-top: 8px;
     border-radius: 15px;
     font-size: 0.85rem;
     font-family: sans-serif;
     display: none;
     box-shadow: 0 1px 4px rgba(0,0,0,0.4);
     border: 1px solid var(--comment-ui-border);
     cursor: default;
     transition: transform 0.2s ease-out;
 }

 #comment-management-wrapper {
     display: flex;
     flex-direction: column;
     align-items: flex-end;
     gap: 8px;
     opacity: 0;
     visibility: hidden;
     transform: translateY(10px);
     transition: all 0.2s ease-out;
 }

 #comment-management-flyout {
     display: flex;
     gap: 0.5rem;
     padding: 8px;
     background-color: rgba(26, 42, 26, 0.9);
     backdrop-filter: blur(5px);
     border: 1px solid var(--comment-ui-border);
     border-radius: 8px;
 }

 #comment-management-help-text {
     color: var(--comment-ui-border);
     font-size: 0.75rem;
     font-family: sans-serif;
     text-align: right;
     padding: 0 4px;
     max-width: 250px;
 }

 #comment-widget-container:hover #comment-management-wrapper {
     opacity: 1;
     visibility: visible;
     transform: translateY(0);
 }

 #comment-widget-container:hover #comment-counter {
     transform: scale(1.05);
 }

 #comment-management-flyout button,
 #comment-management-flyout .file-input-label {
     background-color: var(--comment-ui-accent);
     color: var(--bg-color);
     font-weight: bold;
     border: none;
     padding: 0.5rem 0.8rem;
     border-radius: 5px;
     cursor: pointer;
     font-size: 0.8rem;
     font-family: sans-serif;
     white-space: nowrap;
     display: flex;
     align-items: center;
     justify-content: center;
 }

 #comment-management-flyout button.secondary {
     background-color: var(--comment-ui-border);
     color: var(--comment-ui-text);
     font-weight: normal;
 }

 #comment-management-flyout button:hover,
 #comment-management-flyout .file-input-label:hover {
     opacity: 0.85;
 }

 #copy-link-btn {
     background-color: #4A5D4A;
 }

 #import-comments-input {
     display: none;
 }

 /* Help Text and Keybinding Styles */
 .comment-help-text {
     font-size: 0.8rem;
     color: var(--comment-ui-border);
     text-align: center;
     width: 100%;
 }

 .comment-help-text kbd {
     background-color: #0c140c;
     border: 1px solid var(--comment-ui-border);
     padding: 2px 6px;
     border-radius: 4px;
     font-family: monospace;
     font-size: 0.75rem;
 }

 /* Comment Summary Section Styles */
 #comment-summary-section {
     max-width: 60em;
     margin: 5em auto;
     padding: 2em;
     border-top: 2px solid var(--comment-ui-border);
     color: var(--comment-ui-text);
 }

 #comment-summary-section h2 {
     font-family: var(--font-heading);
     color: var(--comment-ui-accent);
     text-transform: uppercase;
     margin-top: 0;
     border-bottom: none;
     margin-bottom: 1em;
 }

 #comment-summary-list {
     list-style: none;
     padding: 0;
     margin: 0;
 }

 #comment-summary-list li {
     padding: 1.5em;
     border-bottom: 1px solid var(--comment-ui-border);
     cursor: pointer;
     transition: background-color 0.2s ease;
     position: relative;
 }

 #comment-summary-list li:hover {
     background-color: var(--comment-ui-bg);
 }

 #comment-summary-list li blockquote {
     margin: 0 0 0.5em 0;
     padding-left: 1em;
     border-left: 3px solid var(--comment-ui-accent);
     color: var(--comment-ui-text);
     font-style: italic;
     opacity: 0.8;
 }

 #comment-summary-list li p {
     margin: 0;
     color: var(--comment-ui-text);
     font-family: sans-serif;
 }

 .summary-delete-btn {
     position: absolute;
     top: 5px;
     right: 5px;
     font-size: 1.5rem;
     color: var(--comment-ui-border);
     transition: color 0.2s ease;
     line-height: 1;
     padding: 10px;
 }

 .summary-delete-btn:hover {
     color: #c13434;
 }

 /* Mobile Responsiveness */
 @media (min-width: 600px) {
     #comment-ui-container {
         width: 500px;
         max-width: 90%;
         left: 50%;
         transform: translateX(-50%) translateY(120%);
         border-top-left-radius: 8px;
         border-top-right-radius: 8px;
     }

     #comment-ui-container.visible {
         transform: translateX(-50%) translateY(0);
     }
 }

 /* Style for Resolve button in tooltip and summary */
 .resolve-comment-btn {
     background-color: var(--comment-ui-accent);
     color: var(--bg-color);
     font-weight: bold;
     border: none;
     padding: 4px 8px;
     margin-top: 8px;
     margin-right: 5px;
     border-radius: 3px;
     cursor: pointer;
     font-size: 0.8rem;
 }

 .resolve-comment-btn:hover {
     opacity: 0.85;
 }

 .summary-unresolve-btn {
     background-color: var(--comment-ui-accent);
     color: var(--bg-color);
     font-weight: bold;
     border: none;
     padding: 6px 12px;
     border-radius: 4px;
     cursor: pointer;
     font-size: 0.85rem;
     margin-top: 10px;
     display: inline-block;
 }

 .summary-unresolve-btn:hover {
     opacity: 0.85;
 }

 /* Make the counter look clickable */
 #comment-counter.has-comments {
     cursor: pointer;
 }

 /* Author Attribution Styles */
 .comment-author {
     display: block;
     font-size: 0.8rem;
     font-weight: bold;
     opacity: 0.7;
     margin-bottom: 0.5em;
 }

 #comment-tooltip .comment-author {
     color: var(--comment-ui-accent);
 }

 .summary-author {
     font-weight: bold;
     margin-bottom: 0.5em;
     font-family: sans-serif;
     font-size: 0.9em;
 }

 /* Sandboxed Root Container */
 #commenting-system-root {
     position: fixed;
     top: 0;
     left: 0;
     width: 100%;
     height: 100%;
     z-index: 2147483647;
     pointer-events: none;
     font-family: sans-serif;
     font-size: 16px;
     line-height: 1.5;
 }

 #commenting-system-root > * {
     pointer-events: auto;
 }
</style>

<div id="commenting-system-root">
    <div id="comment-tooltip"></div>

    <div id="comment-widget-container">
        <div id="comment-counter"></div>
        <div id="comment-management-wrapper">
            <div id="comment-management-flyout">
                <button id="copy-link-btn">Copy Link</button>
                <label for="import-comments-input" class="file-input-label">Import</label>
                <input type="file" id="import-comments-input" accept=".json"/>
                <button id="export-comments-btn">Export</button>
                <button id="clear-comments-btn" class="secondary">Clear All</button>
            </div>
            <small id="comment-management-help-text">
                Comments are stored locally in your browser. Use Export/Import or Copy Link to share.
            </small>
        </div>
    </div>

    <div id="comment-ui-container">
        <button id="add-comment-btn" style="display: none;">Add Comment</button>
        <div id="add-comment-help-text" class="comment-help-text" style="display: none;">
            Press <kbd>Shift</kbd> + <kbd>Enter</kbd> to add comment
        </div>
        <form id="comment-form">
            <textarea id="comment-input-area" placeholder="Type your comment here..."></textarea>
            <div class="comment-help-text">
                <kbd>Shift</kbd> + <kbd>Enter</kbd> to save, <kbd>Esc</kbd> to cancel
            </div>
            <div class="form-buttons">
                <button type="button" id="cancel-comment-btn" class="secondary">Cancel</button>
                <button type="submit" id="save-comment-btn">Save</button>
            </div>
        </form>
    </div>
</div>

<section id="comment-summary-section" style="display: none;">
    <h2>Comment Summary</h2>
    <ol id="comment-summary-list"></ol>
</section>


<script>
(function() {
    'use strict';

    /**
     * ===================================================================
     *  1. MODULE DEFINITIONS
     * ===================================================================
     */
    const CommentingSystem = {

        // --- Utils Module ---
        Utils: {
            generateCID(commentData) {
                const str = commentData.range.text + commentData.author + commentData.text;
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash |= 0; // Convert to 32bit integer
                }
                return 'cid-' + Math.abs(hash).toString(36);
            },
            escapeHTML(str) {
                const div = document.createElement('div');
                div.textContent = str;
                return div.innerHTML;
            },
            generateUUID() {
                return 'comment-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            },
            toUrlSafeBase64(buffer) {
                return btoa(String.fromCharCode.apply(null, new Uint8Array(buffer)))
                    .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
            },
            fromUrlSafeBase64(str) {
                str = str.replace(/-/g, '+').replace(/_/g, '/');
                while (str.length % 4) { str += '='; }
                const binaryString = atob(str);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            },
            async compressData(data) {
                if (!window.CompressionStream) {
                    console.warn("CompressionStream API not supported. Sharing links may be less reliable.");
                    return new TextEncoder().encode(JSON.stringify(data));
                }
                const stream = new Blob([JSON.stringify(data)], { type: 'application/json' })
                    .stream().pipeThrough(new CompressionStream('gzip'));
                return await new Response(stream).arrayBuffer();
            },
            async decompressData(compressedBuffer) {
                if (!window.DecompressionStream) {
                    console.warn("DecompressionStream API not supported. Cannot load comments from compressed link.");
                    return null;
                }
                try {
                    const stream = new Blob([compressedBuffer], { type: 'application/gzip' })
                        .stream().pipeThrough(new DecompressionStream('gzip'));
                    return await new Response(stream).json();
                } catch (e) {
                    console.error("Decompression failed:", e);
                    return null;
                }
            },
            getAuthorColor(author) {
                if (!author) return { border: '#33ff99', background: 'rgba(51, 255, 153, 0.4)' };
                let hash = 0;
                for (let i = 0; i < author.length; i++) {
                    hash = author.charCodeAt(i) + ((hash << 5) - hash);
                }
                const h = hash % 360;
                return {
                    border: `hsl(${h}, 70%, 40%)`,
                    background: `hsla(${h}, 70%, 85%, 0.4)`
                };
            }
        },

        // --- State Module ---
        State: {
            comments: [],
            currentUser: 'Anonymous',
            currentSelection: null,
            listeners: {},
            init() {
                this.comments = [];
                this.currentUser = 'Anonymous';
                this.currentSelection = null;
                this.listeners = {};
            },
            on(eventName, callback) {
                if (!this.listeners[eventName]) {
                    this.listeners[eventName] = [];
                }
                this.listeners[eventName].push(callback);
            },
            emit(eventName, data) {
                if (this.listeners[eventName]) {
                    this.listeners[eventName].forEach(callback => callback(data));
                }
            },
            setComments(newComments) {
                if (Array.isArray(newComments)) {
                    this.comments = newComments;
                    this.emit('load', this.comments);
                    this.emit('change');
                }
            },
            addComment(commentData) {
                const newComment = {
                    cid: CommentingSystem.Utils.generateCID(commentData),
                    text: commentData.text,
                    range: commentData.range,
                    author: this.currentUser,
                    isResolved: false,
                    createdAt: Date.now(),
                    updatedAt: Date.now()
                };
                this.comments.push(newComment);
                this.emit('comment:added', newComment);
                this.emit('change');
                return newComment;
            },
            deleteComment(commentCid) {
                const comment = this.comments.find(c => c.cid === commentCid);
                if (comment) {
                    // Convert to tombstone by removing all properties except CID and metadata
                    const tombstone = {
                        cid: comment.cid,
                        author: comment.author, // Keep author for tombstone identification
                        isResolved: comment.isResolved,
                        createdAt: comment.createdAt,
                        updatedAt: Date.now()
                    };
                    // Replace the comment with the tombstone
                    const index = this.comments.indexOf(comment);
                    if (index !== -1) {
                        this.comments[index] = tombstone;
                    }
                    this.emit('comment:deleted', tombstone);
                    this.emit('change');
                }
            },
            purgeComment(commentCid) {
                const comment = this.comments.find(c => c.cid === commentCid);
                if (comment) {
                    this.comments = this.comments.filter(c => c.cid !== commentCid);
                    // Emit the same events as a regular deletion so the UI reacts correctly
                    this.emit('comment:deleted', comment);
                    this.emit('change');
                }
            },
            resolveComment(commentCid, isResolved = true) {
                const comment = this.comments.find(c => c.cid === commentCid);
                if (comment) {
                    comment.isResolved = isResolved;
                    comment.updatedAt = Date.now();
                    this.emit('comment:resolved', comment);
                    this.emit('change');
                }
            },
            setCurrentSelection(selectionData) { this.currentSelection = selectionData; },
            setCurrentUser(username) { this.currentUser = username; }
        },

        // --- DOM Module ---
        DOM: {
            elements: {},
            init(contentRootNode) {
                this.elements = {
                    contentRoot: contentRootNode,
                    commentingRoot: document.getElementById('commenting-system-root'),
                    tooltip: document.getElementById('comment-tooltip'),
                    widgetContainer: document.getElementById('comment-widget-container'),
                    counter: document.getElementById('comment-counter'),
                    uiContainer: document.getElementById('comment-ui-container'),
                    addCommentBtn: document.getElementById('add-comment-btn'),
                    addCommentHelpText: document.getElementById('add-comment-help-text'),
                    commentForm: document.getElementById('comment-form'),
                    commentInput: document.getElementById('comment-input-area'),
                    summarySection: document.getElementById('comment-summary-section'),
                    summaryList: document.getElementById('comment-summary-list'),
                };
            },
            renderCommentSummary(comments) {
                this.elements.summaryList.innerHTML = '';
                const commentsToRender = comments.filter(c => c.range && c.text); // Filter out tombstones
                if (commentsToRender.length === 0) {
                    this.elements.summarySection.style.display = 'none';
                    return;
                }
                this.elements.summarySection.style.display = 'block';
                commentsToRender.forEach(comment => {
                    const li = document.createElement('li');
                    li.dataset.commentCid = comment.cid;
                    const authorColors = CommentingSystem.Utils.getAuthorColor(comment.author);
                    const quoteText = comment.range.text.length > 100 ? comment.range.text.substring(0, 97) + '...' : comment.range.text;
                    li.innerHTML = `
                        <span class="summary-delete-btn" data-comment-cid="${comment.cid}">&times;</span>
                        <div class="summary-author" style="color: ${authorColors.border};">By: ${CommentingSystem.Utils.escapeHTML(comment.author)}</div>
                        <blockquote style="border-left-color: ${authorColors.border};">${CommentingSystem.Utils.escapeHTML(quoteText)}</blockquote>
                        <p>${CommentingSystem.Utils.escapeHTML(comment.text)}</p>
                        ${comment.isResolved ? `<button class="summary-unresolve-btn" data-comment-cid="${comment.cid}">Unresolve</button>` : ''}
                    `;
                    if (comment.isResolved) li.classList.add('resolved');
                    this.elements.summaryList.appendChild(li);
                });
            },
            updateCounter(comments) {
                const totalCount = comments.filter(c => c.range && c.text).length; // Count only non-tombstones
                this.elements.counter.style.display = 'block';
                if (totalCount === 0) {
                    this.elements.counter.textContent = 'No Comments';
                    this.elements.counter.classList.remove('has-comments');
                    return;
                }
                const placedCount = document.querySelectorAll('.comment-highlight').length;
                this.elements.counter.textContent = `${placedCount} Comment${placedCount !== 1 ? 's' : ''}`;
                if (placedCount > 0) this.elements.counter.classList.add('has-comments');
                else this.elements.counter.classList.remove('has-comments');
            },
            showTooltip(comment, highlightEl) {
                if (!comment) return;
                const authorColors = CommentingSystem.Utils.getAuthorColor(comment.author);
                this.elements.tooltip.innerHTML = `
                    <small class="comment-author" style="color: ${authorColors.border};">By: ${CommentingSystem.Utils.escapeHTML(comment.author)}</small>
                    <span>${CommentingSystem.Utils.escapeHTML(comment.text)}</span> <br/>
                    <button class="resolve-comment-btn" data-comment-cid="${comment.cid}">Resolve</button>
                    <button class="delete-comment-btn" data-comment-cid="${comment.cid}">Delete</button>`;
                this.elements.tooltip.style.display = 'block';
                this.elements.tooltip.dataset.activeCommentCid = comment.cid;
                const highlightRect = highlightEl.getBoundingClientRect();
                const tooltipRect = this.elements.tooltip.getBoundingClientRect();
                let newLeft = highlightRect.left;
                if (newLeft + tooltipRect.width > window.innerWidth) newLeft = window.innerWidth - tooltipRect.width - 10;
                newLeft = Math.max(10, newLeft);
                let newTop = highlightRect.bottom + 5;
                if (newTop + tooltipRect.height > window.innerHeight) newTop = highlightRect.top - tooltipRect.height - 5;
                newTop = Math.max(10, newTop);
                this.elements.tooltip.style.left = `${newLeft}px`;
                this.elements.tooltip.style.top = `${newTop}px`;
            },
            hideTooltip() { this.elements.tooltip.style.display = 'none'; this.elements.tooltip.dataset.activeCommentCid = ''; },
            showCommentDrawer() { this.elements.uiContainer.classList.add('visible'); this.elements.addCommentBtn.style.display = 'block'; this.elements.addCommentHelpText.style.display = 'block'; this.elements.commentForm.style.display = 'none'; },
            showCommentForm() { this.elements.addCommentBtn.style.display = 'none'; this.elements.addCommentHelpText.style.display = 'none'; this.elements.commentForm.style.display = 'flex'; this.elements.commentInput.focus(); },
            resetUI() { this.elements.uiContainer.classList.remove('visible'); this.elements.addCommentBtn.style.display = 'none'; this.elements.addCommentHelpText.style.display = 'none'; this.elements.commentForm.style.display = 'none'; this.elements.commentInput.value = ''; if (window.getSelection) window.getSelection().removeAllRanges(); },
            removeHighlight(commentCid) {
                document.querySelectorAll(`.comment-highlight[data-comment-cid="${commentCid}"]`).forEach(el => {
                    const parent = el.parentNode;
                    if (parent) {
                        while (el.firstChild) parent.insertBefore(el.firstChild, el);
                        parent.removeChild(el);
                        parent.normalize();
                    }
                });
            }
        },

        // --- Highlighting Module ---
        Highlighting: {
            contentRoot: null,
            init(contentRootNode) { this.contentRoot = contentRootNode; },
            getNodePath(node) {
                const path = [];
                while (node && node !== this.contentRoot) {
                    let sibling = node, index = 0;
                    while ((sibling = sibling.previousSibling) != null) index++;
                    path.unshift(index);
                    node = node.parentNode;
                }
                return path;
            },
            getNodeFromPath(path) {
                if (!Array.isArray(path)) return null;
                let node = this.contentRoot;
                for (const index of path) {
                    if (!Number.isInteger(index) || index < 0 || !node || !node.childNodes[index]) return null;
                    node = node.childNodes[index];
                }
                return node;
            },
            serializeRange(range) {
                if (!range) return null;
                return { startPath: this.getNodePath(range.startContainer), startOffset: range.startOffset, endPath: this.getNodePath(range.endContainer), endOffset: range.endOffset, text: range.toString() };
            },
            deserializeRange(savedRange) {
                const startContainer = this.getNodeFromPath(savedRange.startPath);
                const endContainer = this.getNodeFromPath(savedRange.endPath);
                if (startContainer && endContainer) {
                    try {
                        const range = document.createRange();
                        range.setStart(startContainer, Math.min(savedRange.startOffset, startContainer.textContent.length));
                        range.setEnd(endContainer, Math.min(savedRange.endOffset, endContainer.textContent.length));
                        return range;
                    } catch (e) { console.error("Error creating range from path.", e, savedRange); }
                }
                const walker = document.createTreeWalker(this.contentRoot, NodeFilter.SHOW_TEXT);
                let node;
                const normalizedText = savedRange.text.replace(/\s+/g, ' ').trim();
                if (!normalizedText) return null;
                while (node = walker.nextNode()) {
                    const index = node.nodeValue.replace(/\s+/g, ' ').indexOf(normalizedText);
                    if (index !== -1) {
                        const range = document.createRange();
                        range.setStart(node, index);
                        range.setEnd(node, index + normalizedText.length);
                        return range;
                    }
                }
                return null;
            },
            applyHighlight(range, comment) {
                if (!range || range.collapsed) return null;
                const authorColors = CommentingSystem.Utils.getAuthorColor(comment.author);
                const marker = document.createElement('mark');
                marker.className = 'comment-highlight';
                marker.dataset.commentCid = comment.cid;
                marker.style.backgroundColor = authorColors.background;
                marker.style.borderBottomColor = authorColors.border;
                try {
                    range.surroundContents(marker);
                } catch (e) {
                    console.warn("surroundContents failed. Using robust fallback.", e);
                    const walker = document.createTreeWalker(range.commonAncestorContainer, NodeFilter.SHOW_TEXT);
                    const textNodes = [];
                    while (walker.nextNode()) {
                        if (range.intersectsNode(walker.currentNode)) textNodes.push(walker.currentNode);
                    }
                    for (const node of textNodes) {
                        const highlightRange = document.createRange();
                        highlightRange.setStart(node, node === range.startContainer ? range.startOffset : 0);
                        highlightRange.setEnd(node, node === range.endContainer ? range.endOffset : node.textContent.length);
                        if (!highlightRange.collapsed) {
                            const localMarker = marker.cloneNode(true);
                            highlightRange.surroundContents(localMarker);
                        }
                    }
                }
            },
            applyAllHighlights(comments) {
                const itemsToHighlight = comments
                    .filter(c => !c.isResolved && c.range && c.text) // Filter out tombstones and resolved comments
                    .map(comment => ({ comment, range: this.deserializeRange(comment.range) }))
                    .filter(item => item.range)
                    .sort((a, b) => b.range.compareBoundaryPoints(Range.START_TO_START, a.range));
                itemsToHighlight.forEach(item => this.applyHighlight(item.range, item.comment));
            }
        },
        
        // --- Persistence Module ---
        Persistence: {
            State: null, Utils: null,
            init(stateModule, utilsModule) {
                this.State = stateModule;
                this.Utils = utilsModule;
            },
            saveToLocal() { try { localStorage.setItem('userComments', JSON.stringify(this.State.comments)); } catch (e) { console.error("Could not save comments to localStorage.", e); } },
            loadFromLocal() {
                const savedCommentsJSON = localStorage.getItem('userComments');
                if (savedCommentsJSON) {
                    try {
                        const comments = JSON.parse(savedCommentsJSON) || [];
                        // Backward compatibility: Convert old-style tombstones (with isDeleted: true) 
                        // to new-style tombstones (missing range and text)
                        return comments.map(comment => {
                            if (comment.isDeleted) {
                                // Convert to new-style tombstone
                                return {
                                    cid: comment.cid,
                                    author: comment.author,
                                    isResolved: comment.isResolved,
                                    createdAt: comment.createdAt,
                                    updatedAt: comment.updatedAt || Date.now()
                                };
                            }
                            return comment;
                        });
                    } catch (e) { return []; }
                }
                return [];
            },
            getOrSetUser() {
                const savedUser = localStorage.getItem('commentingUser');
                if (savedUser) { this.State.setCurrentUser(savedUser); return; }
                const newUser = prompt("Please enter your name for commenting:", "Anonymous");
                const user = (newUser && newUser.trim()) ? newUser.trim() : 'Anonymous';
                this.State.setCurrentUser(user);
                localStorage.setItem('commentingUser', user);
            },
            async generateShareableLink(buttonEl) {
                if (this.State.comments.length === 0) return;
                const originalText = buttonEl.textContent;
                buttonEl.textContent = 'Compressing...';
                buttonEl.disabled = true;
                try {
                    // Create the highly optimized lightweight format
                    const lightweightComments = this.State.comments.map(comment => {
                        // A comment is a tombstone if it's missing range and text properties
                        if (!comment.range && !comment.text) {
                            return {
                                cid: comment.cid,
                                updatedAt: comment.updatedAt
                            };
                        }
                        return {
                            cid: comment.cid,
                            text: comment.text,
                            range: comment.range,
                            author: comment.author,
                            isResolved: comment.isResolved, // Will be false or true
                            updatedAt: comment.updatedAt
                        };
                    });

                    const compressed = await this.Utils.compressData(lightweightComments);
                    const base64 = this.Utils.toUrlSafeBase64(compressed);
                    const url = new URL(window.location);
                    url.hash = base64;
                    await navigator.clipboard.writeText(url.href);
                    
                    // After sharing, purge tombstones from local state
                    this._purgeTombstones();
                    
                    buttonEl.textContent = 'Copied!';
                } catch (err) {
                    console.error("Failed to copy link:", err);
                    buttonEl.textContent = 'Error!';
                } finally {
                    setTimeout(() => {
                        buttonEl.textContent = originalText;
                        buttonEl.disabled = false;
                    }, 2000);
                }
            },
            exportToFile() {
                if (this.State.comments.length === 0) { return; }
                const dataStr = JSON.stringify(this.State.comments, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'comments.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // After exporting, purge tombstones from local state
                this._purgeTombstones();
            },
            _applyMerge(incomingComments) {
                const { State, Utils } = this;
                // Create a lookup map from CID to the full local comment object.
                const localCommentsByCID = new Map(State.comments.map(c => [c.cid, c]));
                let changesMade = false;

                for (const incoming of incomingComments) {
                    // Backwards compatibility for data formats
                    const cid = incoming.cid || Utils.generateCID(incoming);
                    const incomingTimestamp = incoming.updatedAt || incoming.t || Date.now();
                    // A comment is a tombstone if it's missing range and text properties
                    const isTombstone = !incoming.range && !incoming.text;

                    const localComment = localCommentsByCID.get(cid);

                    if (isTombstone) {
                        // If we have this comment and the incoming tombstone is newer,
                        // command the State module to delete our copy.
                        if (localComment && incomingTimestamp > localComment.updatedAt) {
                            State.purgeComment(cid); // Use the CID to delete
                            changesMade = true;
                        }
                        // If we don't have the comment, or ours is newer, we simply discard the tombstone.
                        continue;
                    }

                    if (!localComment) {
                        // It's a new comment. We command the State module to add it.
                        // We must construct the full comment object first.
                        const newCommentData = {
                            text: incoming.text,
                            range: incoming.range,
                            author: incoming.author
                        };
                        // Manually add the rest of the metadata before adding
                        const newComment = State.addComment(newCommentData);
                        newComment.cid = cid;
                        newComment.createdAt = incoming.createdAt || incomingTimestamp;
                        newComment.updatedAt = incomingTimestamp;
                        newComment.isResolved = !!(incoming.isResolved || incoming.r);
                        changesMade = true;
                    } else if (incomingTimestamp > localComment.updatedAt) {
                        // It's an update. We command the State module to update our copy.
                        // For now, the only update is resolution status.
                        const newResolution = !!(incoming.isResolved || incoming.r);
                        if (localComment.isResolved !== newResolution) {
                           State.resolveComment(cid, newResolution);
                        }
                        // Update timestamp regardless to prevent reprocessing old updates
                        localComment.updatedAt = incomingTimestamp;
                        changesMade = true;
                    }
                }
                
                // If the only change was a deletion, the 'change' event was already fired.
                // But if we only added/updated, we need to manually trigger a final 'change'
                // to ensure things like the summary list re-render with new timestamps.
                if (changesMade) {
                    State.emit('change');
                }
            },

            async loadInitialComments() {
                let localComments = this.loadFromLocal();
                // Backwards compatibility: Ensure old local comments get CIDs
                localComments.forEach(c => {
                    if (!c.cid) c.cid = this.Utils.generateCID(c);
                    if (!c.updatedAt) c.updatedAt = c.createdAt || Date.now();
                });

                // Set initial state from local storage first.
                this.State.setComments(localComments);

                const hash = window.location.hash.slice(1);
                if (hash) {
                    try {
                        const buffer = this.Utils.fromUrlSafeBase64(hash);
                        const lightweightComments = await this.Utils.decompressData(buffer);
                        if (lightweightComments && Array.isArray(lightweightComments)) {
                            this._applyMerge(lightweightComments);
                            history.replaceState(null, '', window.location.pathname + window.location.search);
                        }
                    } catch (e) {
                        console.error("Failed to load or merge comments from URL hash", e);
                    }
                }
            },

            importFromFile(file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const importedComments = JSON.parse(event.target.result);
                        if (Array.isArray(importedComments)) {
                           this._applyMerge(importedComments);
                           alert(`Import processed successfully.`);
                        }
                    } catch (err) { alert('Error: Could not parse file.'); }
                };
                reader.readAsText(file);
            },
            _purgeTombstones() {
                // Remove all tombstones (comments without range and text) from local state
                const { State } = this;
                const tombstones = State.comments.filter(c => !c.range && !c.text);
                tombstones.forEach(tombstone => {
                    State.purgeComment(tombstone.cid);
                });
            },
        },

        // --- UI (Controller) Module ---
        UI: {
            modules: {},
            nextHighlightIndex: 0,
            init(modules) {
                this.modules = modules;
                this.bindEventListeners();
                this.initializeViewportPositioning();
                this.bindStateListeners();
            },
            syncRootWithViewport() {
                if (!window.visualViewport) return;
                const { offsetTop, offsetLeft, width, height } = window.visualViewport;
                const rootEl = this.modules.DOM.elements.commentingRoot;
                const trueTop = offsetTop + window.scrollY;
                const trueLeft = offsetLeft + window.scrollX;
                rootEl.style.transform = `translate(${trueLeft}px, ${trueTop}px)`;
                rootEl.style.width = `${width}px`;
                rootEl.style.height = `${height}px`;
            },
            initializeViewportPositioning() {
                const isMobileLike = navigator.maxTouchPoints > 0;
                if (isMobileLike && window.visualViewport) {
                    const rootEl = this.modules.DOM.elements.commentingRoot;
                    rootEl.style.position = 'absolute';
                    window.visualViewport.addEventListener('resize', this.syncRootWithViewport.bind(this));
                    window.visualViewport.addEventListener('scroll', this.syncRootWithViewport.bind(this));
                    this.syncRootWithViewport();
                }
            },
            bindStateListeners() {
                const { State, DOM, Highlighting, Persistence } = this.modules;
                State.on('load', (comments) => {
                    Highlighting.applyAllHighlights(comments);
                    this.addEventListenersToHighlights();
                });
                State.on('comment:added', (newComment) => {
                    const range = Highlighting.deserializeRange(newComment.range);
                    if (range) {
                        Highlighting.applyHighlight(range, newComment);
                        this.addEventListenersToHighlights();
                    }
                });
                State.on('comment:deleted', (deletedComment) => {
                    DOM.removeHighlight(deletedComment.cid);
                });
                State.on('comment:resolved', (comment) => {
                    if (comment.isResolved) {
                        DOM.removeHighlight(comment.cid);
                    } else {
                        const range = Highlighting.deserializeRange(comment.range);
                        if (range) {
                            Highlighting.applyHighlight(range, comment);
                            this.addEventListenersToHighlights();
                        }
                    }
                });
                State.on('change', () => {
                    DOM.renderCommentSummary(State.comments);
                    DOM.updateCounter(State.comments);
                    Persistence.saveToLocal();
                });
            },
            bindEventListeners() {
                const { contentRoot } = this.modules.DOM.elements;

                contentRoot.addEventListener('mouseup', this.handleSelectionEnd.bind(this));
                contentRoot.addEventListener('touchend', this.handleSelectionEnd.bind(this));

                this.modules.DOM.elements.addCommentBtn.addEventListener('click', this.handleAddCommentClick.bind(this));
                this.modules.DOM.elements.commentForm.addEventListener('submit', this.handleSaveComment.bind(this));
                document.getElementById('cancel-comment-btn').addEventListener('click', () => this.modules.DOM.resetUI());
                this.modules.DOM.elements.commentInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && e.shiftKey) { e.preventDefault(); this.modules.DOM.elements.commentForm.requestSubmit(); }
                    if (e.key === 'Escape') { e.preventDefault(); this.modules.DOM.resetUI(); }
                });
                document.getElementById('export-comments-btn').addEventListener('click', () => this.modules.Persistence.exportToFile());
                document.getElementById('import-comments-input').addEventListener('change', (e) => e.target.files[0] && this.modules.Persistence.importFromFile(e.target.files[0]));
                document.getElementById('copy-link-btn').addEventListener('click', (e) => this.modules.Persistence.generateShareableLink(e.target));
                document.getElementById('clear-comments-btn').addEventListener('click', this.handleClearAll.bind(this));
                document.addEventListener('click', this.handleDocumentClick.bind(this));
                this.modules.DOM.elements.summaryList.addEventListener('click', this.handleSummaryClick.bind(this));
                this.modules.DOM.elements.widgetContainer.addEventListener('click', this.handleCycleHighlights.bind(this));
            },
            addEventListenersToHighlights() {
                document.querySelectorAll('.comment-highlight').forEach(marker => {
                    if (marker.dataset.listenerAttached) return;
                    marker.addEventListener('click', this.handleHighlightClick.bind(this));
                    marker.dataset.listenerAttached = 'true';
                });
            },
            handleSelectionEnd(e) {
                if (e.target.closest('#commenting-system-root')) return;
                setTimeout(() => {
                    const selection = window.getSelection();
                    if (selection && !selection.isCollapsed && this.modules.DOM.elements.contentRoot.contains(selection.anchorNode)) {
                        this.modules.DOM.showCommentDrawer();
                    } else if (document.activeElement !== this.modules.DOM.elements.commentInput) {
                        this.modules.DOM.resetUI();
                    }
                }, 10);
            },
            handleAddCommentClick() {
                const selection = window.getSelection();
                if (selection && !selection.isCollapsed) {
                    const serializedRange = this.modules.Highlighting.serializeRange(selection.getRangeAt(0));
                    this.modules.State.setCurrentSelection(serializedRange);
                    this.modules.Persistence.getOrSetUser();
                    this.modules.DOM.showCommentForm();
                }
            },
            handleSaveComment(e) {
                e.preventDefault();
                const { State, DOM } = this.modules;
                const text = DOM.elements.commentInput.value.trim();
                const rangeData = State.currentSelection;
                if (text && rangeData) {
                    State.addComment({ text, range: rangeData });
                    DOM.resetUI();
                }
            },
            handleHighlightClick(e) {
                e.stopPropagation();
                const { DOM, State } = this.modules;
                const marker = e.target.closest('.comment-highlight');
                if (!marker) return;
                const commentCid = marker.dataset.commentCid;
                if (DOM.elements.tooltip.dataset.activeCommentCid === commentCid) {
                    DOM.hideTooltip();
                } else {
                    const comment = State.comments.find(c => c.cid === commentCid);
                    if (comment) DOM.showTooltip(comment, marker);
                }
            },
            handleDocumentClick(e) {
                const { DOM, State } = this.modules;
                if (!e.target.closest('.comment-highlight') && !e.target.closest('#comment-tooltip')) DOM.hideTooltip();
                const deleteBtn = e.target.closest('.delete-comment-btn');
                if (deleteBtn && confirm('Are you sure you want to delete this comment?')) {
                    State.deleteComment(deleteBtn.dataset.commentCid);
                    DOM.hideTooltip();
                }
                const resolveBtn = e.target.closest('.resolve-comment-btn');
                if (resolveBtn) {
                    State.resolveComment(resolveBtn.dataset.commentCid, true);
                    DOM.hideTooltip();
                }
            },
            handleSummaryClick(e) {
                const { DOM, State } = this.modules;
                const li = e.target.closest('li');
                if (!li) return;
                const commentCid = li.dataset.commentCid;
                if (e.target.closest('.summary-delete-btn') && confirm('Are you sure you want to delete this comment?')) {
                    State.deleteComment(commentCid);
                } else if (e.target.closest('.summary-unresolve-btn')) {
                    State.resolveComment(commentCid, false);
                } else {
                    const highlightEl = document.querySelector(`.comment-highlight[data-comment-cid="${commentCid}"]`);
                    if (highlightEl) {
                        highlightEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        setTimeout(() => {
                           const comment = State.comments.find(c => c.cid === commentCid);
                           DOM.showTooltip(comment, highlightEl);
                        }, 300);
                    }
                }
            },
            // FIX: The handler now explicitly removes DOM elements before clearing the state.
            handleClearAll() {
                const { State, DOM } = this.modules;
                if (confirm('Are you sure you want to permanently delete all comments?')) {
                    // 1. Explicitly remove all highlight DOM elements.
                    [...State.comments].forEach(comment => {
                        DOM.removeHighlight(comment.cid);
                    });
                    // 2. Now, update the application state.
                    State.setComments([]);
                    history.replaceState(null, '', window.location.pathname);
                }
            },
            handleCycleHighlights(e) {
                if (e.target.closest('#comment-management-flyout')) return;
                const highlights = Array.from(document.querySelectorAll('.comment-highlight')).sort((a, b) => {
                    const aRect = a.getBoundingClientRect();
                    const bRect = b.getBoundingClientRect();
                    return aRect.top - bRect.top;
                });
                if (highlights.length === 0) return;
                if (this.nextHighlightIndex >= highlights.length) this.nextHighlightIndex = 0;
                const nextHighlight = highlights[this.nextHighlightIndex];
                if (nextHighlight) {
                    nextHighlight.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    nextHighlight.click();
                }
                this.nextHighlightIndex = (this.nextHighlightIndex + 1) % highlights.length;
            }
        }
    };

    /**
     * ===================================================================
     *  2. PUBLIC INITIALIZER
     * ===================================================================
     */
    window.initializeCommentingSystem = async function(rootElementId) {
        if (window.commentingSystemInitialized) return;

        const { State, DOM, Highlighting, Persistence, UI } = CommentingSystem;
        const contentRootNode = document.getElementById(rootElementId) || document.body;

        State.init();
        
        DOM.init(contentRootNode);
        Highlighting.init(contentRootNode);
        Persistence.init(State, CommentingSystem.Utils);
        
        UI.init({ State, DOM, Highlighting, Persistence, Utils: CommentingSystem.Utils });

        Persistence.getOrSetUser();
        await Persistence.loadInitialComments();
        
        window.commentingSystemInitialized = true;
        console.log("Commenting system initialized successfully.");
    };

    /**
     * ===================================================================
     *  3. DOM READY HOOK
     * ===================================================================
     */
    document.addEventListener('DOMContentLoaded', () => {
        initializeCommentingSystem('content');
    });

})();
</script>
